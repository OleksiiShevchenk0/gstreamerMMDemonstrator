<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>gstreamermm: Gst::Clock Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">gstreamermm
   &#160;<span id="projectnumber">1.10.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceGst.html">Gst</a></li><li class="navelem"><a class="el" href="classGst_1_1Clock.html">Clock</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classGst_1_1Clock-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Gst::Clock Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Abstract class for global clocks GStreamer uses a global clock to synchronize the plugins in a pipeline.  
 <a href="classGst_1_1Clock.html#details">More...</a></p>

<p><code>#include &lt;gstreamermm/clock.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Gst::Clock:</div>
<div class="dyncontent">
<div class="center"><img src="classGst_1_1Clock__inherit__graph.png" border="0" usemap="#Gst_1_1Clock_inherit__map" alt="Inheritance graph"/></div>
<map name="Gst_1_1Clock_inherit__map" id="Gst_1_1Clock_inherit__map">
<area shape="rect" id="node3" href="classGst_1_1SystemClock.html" title="A default clock that uses the current system time. " alt="" coords="78,155,213,181"/>
<area shape="rect" id="node2" href="classGst_1_1Object.html" title="A base class for the GStreamer object hierarchy. " alt="" coords="99,5,192,32"/>
<area shape="rect" id="node4" href="classGst_1_1AudioClock.html" title="A Helper object for implementing audio clocks. " alt="" coords="5,229,128,256"/>
<area shape="rect" id="node5" href="classGst_1_1NetClientClock.html" title="Special clock that synchronizes to a remote time provider. " alt="" coords="153,229,298,256"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1b9f5dc210f002c6fb4a62b13cfcb0b8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Clock.html#a1b9f5dc210f002c6fb4a62b13cfcb0b8">Clock</a> (<a class="el" href="classGst_1_1Clock.html">Clock</a>&amp;&amp; src) noexcept</td></tr>
<tr class="separator:a1b9f5dc210f002c6fb4a62b13cfcb0b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0149011f8e53ffdf3df0a6d0f2dc479c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGst_1_1Clock.html">Clock</a>&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Clock.html#a0149011f8e53ffdf3df0a6d0f2dc479c">operator=</a> (<a class="el" href="classGst_1_1Clock.html">Clock</a>&amp;&amp; src) noexcept</td></tr>
<tr class="separator:a0149011f8e53ffdf3df0a6d0f2dc479c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9e465fc7ec0a9406fb8d9017ddbd67d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Clock.html#ac9e465fc7ec0a9406fb8d9017ddbd67d">~Clock</a> () noexcept override</td></tr>
<tr class="separator:ac9e465fc7ec0a9406fb8d9017ddbd67d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0459a0384c1e5432b82764c7810f05d"><td class="memItemLeft" align="right" valign="top">GstClock*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Clock.html#aa0459a0384c1e5432b82764c7810f05d">gobj</a> ()</td></tr>
<tr class="memdesc:aa0459a0384c1e5432b82764c7810f05d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the underlying C GObject.  <a href="#aa0459a0384c1e5432b82764c7810f05d">More...</a><br /></td></tr>
<tr class="separator:aa0459a0384c1e5432b82764c7810f05d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2563d4c0429a9ed65e3712af76730f26"><td class="memItemLeft" align="right" valign="top">const GstClock*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Clock.html#a2563d4c0429a9ed65e3712af76730f26">gobj</a> () const</td></tr>
<tr class="memdesc:a2563d4c0429a9ed65e3712af76730f26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the underlying C GObject.  <a href="#a2563d4c0429a9ed65e3712af76730f26">More...</a><br /></td></tr>
<tr class="separator:a2563d4c0429a9ed65e3712af76730f26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7273dacc028b733d43ebc92b4f2e6bb"><td class="memItemLeft" align="right" valign="top">GstClock*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Clock.html#ae7273dacc028b733d43ebc92b4f2e6bb">gobj_copy</a> ()</td></tr>
<tr class="memdesc:ae7273dacc028b733d43ebc92b4f2e6bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the underlying C instance. The caller is responsible for unrefing it. Use when directly setting fields in structs.  <a href="#ae7273dacc028b733d43ebc92b4f2e6bb">More...</a><br /></td></tr>
<tr class="separator:ae7273dacc028b733d43ebc92b4f2e6bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa76795d0374dc653b3b31d58652124be"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Clock.html#aa76795d0374dc653b3b31d58652124be">add_observation</a> (<a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a> slave_time, <a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a> master_time, gdouble&amp; result)</td></tr>
<tr class="memdesc:aa76795d0374dc653b3b31d58652124be"><td class="mdescLeft">&#160;</td><td class="mdescRight">The time <em>master_time</em> of the master clock and the time <em>slave_time</em> of the slave clock are added to the list of observations.  <a href="#aa76795d0374dc653b3b31d58652124be">More...</a><br /></td></tr>
<tr class="separator:aa76795d0374dc653b3b31d58652124be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade716899bdeb33ee65b644f28d7b7c1e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Clock.html#ade716899bdeb33ee65b644f28d7b7c1e">add_observation</a> (<a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a> slave_time, <a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a> master_time, gdouble&amp; result, <a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a>&amp;<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01616.html#a084be990a1caf21a3b1ce38fe61bad3f">internal</a>, <a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a>&amp; external, <a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a>&amp; rate_num, <a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a>&amp; rate_denom)</td></tr>
<tr class="memdesc:ade716899bdeb33ee65b644f28d7b7c1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a clock observation to the internal slaving algorithm the same as <a class="el" href="classGst_1_1Clock.html#aa76795d0374dc653b3b31d58652124be" title="The time master_time of the master clock and the time slave_time of the slave clock are added to the ...">add_observation()</a>, and return the result of the master clock estimation, without updating the internal calibration.  <a href="#ade716899bdeb33ee65b644f28d7b7c1e">More...</a><br /></td></tr>
<tr class="separator:ade716899bdeb33ee65b644f28d7b7c1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab85ebe6e289302d83738ccd55bbfe4b6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Clock.html#ab85ebe6e289302d83738ccd55bbfe4b6">set_master</a> (const <a class="el" href="classGst_1_1Clock.html">Clock</a>&amp; master_clock)</td></tr>
<tr class="memdesc:ab85ebe6e289302d83738ccd55bbfe4b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>master_clock</em> as the master clock for <em>clock</em>.  <a href="#ab85ebe6e289302d83738ccd55bbfe4b6">More...</a><br /></td></tr>
<tr class="separator:ab85ebe6e289302d83738ccd55bbfe4b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a305be78c4fdd5050463eb636feeb4c4c"><td class="memItemLeft" align="right" valign="top">Glib::RefPtr&lt; <a class="el" href="classGst_1_1Clock.html">Gst::Clock</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Clock.html#a305be78c4fdd5050463eb636feeb4c4c">get_master</a> ()</td></tr>
<tr class="memdesc:a305be78c4fdd5050463eb636feeb4c4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the master clock that <em>clock</em> is slaved to or <code>nullptr</code> when the clock is not slaved to any master clock.  <a href="#a305be78c4fdd5050463eb636feeb4c4c">More...</a><br /></td></tr>
<tr class="separator:a305be78c4fdd5050463eb636feeb4c4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabf6269b221411dd1be4d3a4a832ec90"><td class="memItemLeft" align="right" valign="top">Glib::RefPtr&lt; const <a class="el" href="classGst_1_1Clock.html">Gst::Clock</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Clock.html#aabf6269b221411dd1be4d3a4a832ec90">get_master</a> () const</td></tr>
<tr class="memdesc:aabf6269b221411dd1be4d3a4a832ec90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the master clock that <em>clock</em> is slaved to or <code>nullptr</code> when the clock is not slaved to any master clock.  <a href="#aabf6269b221411dd1be4d3a4a832ec90">More...</a><br /></td></tr>
<tr class="separator:aabf6269b221411dd1be4d3a4a832ec90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fb3ee60a15a29546a9ed805b15944bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Clock.html#a2fb3ee60a15a29546a9ed805b15944bb">set_resolution</a> (<a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a> resolution)</td></tr>
<tr class="memdesc:a2fb3ee60a15a29546a9ed805b15944bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the accuracy of the clock.  <a href="#a2fb3ee60a15a29546a9ed805b15944bb">More...</a><br /></td></tr>
<tr class="separator:a2fb3ee60a15a29546a9ed805b15944bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35746a3b6a929aa7b62b1c4986a23a40"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Clock.html#a35746a3b6a929aa7b62b1c4986a23a40">get_resolution</a> () const</td></tr>
<tr class="memdesc:a35746a3b6a929aa7b62b1c4986a23a40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the accuracy of the clock.  <a href="#a35746a3b6a929aa7b62b1c4986a23a40">More...</a><br /></td></tr>
<tr class="separator:a35746a3b6a929aa7b62b1c4986a23a40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af263ed436ab5f105f1e6cc71243ed65e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Clock.html#af263ed436ab5f105f1e6cc71243ed65e">get_time</a> () const</td></tr>
<tr class="memdesc:af263ed436ab5f105f1e6cc71243ed65e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current time of the given clock.  <a href="#af263ed436ab5f105f1e6cc71243ed65e">More...</a><br /></td></tr>
<tr class="separator:af263ed436ab5f105f1e6cc71243ed65e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5d5e8edfe6254d46c9ae6a7063fa3cd"><td class="memItemLeft" align="right" valign="top">Glib::RefPtr&lt; <a class="el" href="classGst_1_1ClockID.html">Gst::ClockID</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Clock.html#ae5d5e8edfe6254d46c9ae6a7063fa3cd">create_single_shot_id</a> (<a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a> time)</td></tr>
<tr class="memdesc:ae5d5e8edfe6254d46c9ae6a7063fa3cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a <a class="el" href="classGst_1_1ClockID.html" title="A data type to hold the handle to an outstanding sync or async clock callback. ">Gst::ClockID</a> from <em>clock</em> to trigger a single shot notification at the requested time.  <a href="#ae5d5e8edfe6254d46c9ae6a7063fa3cd">More...</a><br /></td></tr>
<tr class="separator:ae5d5e8edfe6254d46c9ae6a7063fa3cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad82c3164cea026acbc4b7bc797502ad9"><td class="memItemLeft" align="right" valign="top">Glib::RefPtr&lt; <a class="el" href="classGst_1_1ClockID.html">Gst::ClockID</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Clock.html#ad82c3164cea026acbc4b7bc797502ad9">create_periodic_id</a> (<a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a> start_time, <a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a> intervals)</td></tr>
<tr class="memdesc:ad82c3164cea026acbc4b7bc797502ad9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an ID from <em>clock</em> to trigger a periodic notification.  <a href="#ad82c3164cea026acbc4b7bc797502ad9">More...</a><br /></td></tr>
<tr class="separator:ad82c3164cea026acbc4b7bc797502ad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e62295c4f51fd262caba789c4638cb3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Clock.html#a8e62295c4f51fd262caba789c4638cb3">single_shot_id_reinit</a> (const Glib::RefPtr&lt; <a class="el" href="classGst_1_1ClockID.html">Gst::ClockID</a> &gt;&amp; id, <a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a> time)</td></tr>
<tr class="memdesc:a8e62295c4f51fd262caba789c4638cb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reinitializes the provided single shot <em>id</em> to the provided time.  <a href="#a8e62295c4f51fd262caba789c4638cb3">More...</a><br /></td></tr>
<tr class="separator:a8e62295c4f51fd262caba789c4638cb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acef159f9f299d14b275acc5d38ee52f7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Clock.html#acef159f9f299d14b275acc5d38ee52f7">periodic_id_reinit</a> (const Glib::RefPtr&lt; <a class="el" href="classGst_1_1ClockID.html">Gst::ClockID</a> &gt;&amp; id, <a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a> start_time, <a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a> interval)</td></tr>
<tr class="memdesc:acef159f9f299d14b275acc5d38ee52f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reinitializes the provided periodic <em>id</em> to the provided start time and interval.  <a href="#acef159f9f299d14b275acc5d38ee52f7">More...</a><br /></td></tr>
<tr class="separator:acef159f9f299d14b275acc5d38ee52f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e08883b37732a51b00940a8bcd52a49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Clock.html#a6e08883b37732a51b00940a8bcd52a49">get_internal_time</a> () const</td></tr>
<tr class="memdesc:a6e08883b37732a51b00940a8bcd52a49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current internal time of the given clock.  <a href="#a6e08883b37732a51b00940a8bcd52a49">More...</a><br /></td></tr>
<tr class="separator:a6e08883b37732a51b00940a8bcd52a49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f72f5d84ce2735835a26cec51d21de4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Clock.html#a9f72f5d84ce2735835a26cec51d21de4">adjust_unlocked</a> (<a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a> internal_time)</td></tr>
<tr class="memdesc:a9f72f5d84ce2735835a26cec51d21de4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the given <em>internal_time</em> clock time to the external time, adjusting for the rate and reference time set with <a class="el" href="classGst_1_1Clock.html#a12463def9152956a420fcebe24939f4f" title="Adjusts the rate and time of clock. ">set_calibration()</a> and making sure that the returned time is increasing.  <a href="#a9f72f5d84ce2735835a26cec51d21de4">More...</a><br /></td></tr>
<tr class="separator:a9f72f5d84ce2735835a26cec51d21de4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1557212b076a34b36502f87d0cd7c05c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Clock.html#a1557212b076a34b36502f87d0cd7c05c">unadjust_unlocked</a> (<a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a> external_time)</td></tr>
<tr class="memdesc:a1557212b076a34b36502f87d0cd7c05c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the given <em>external_time</em> clock time to the internal time of <em>clock</em>, using the rate and reference time set with <a class="el" href="classGst_1_1Clock.html#a12463def9152956a420fcebe24939f4f" title="Adjusts the rate and time of clock. ">set_calibration()</a>.  <a href="#a1557212b076a34b36502f87d0cd7c05c">More...</a><br /></td></tr>
<tr class="separator:a1557212b076a34b36502f87d0cd7c05c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9d74523eb34b8702a27740c48239b39"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Clock.html#af9d74523eb34b8702a27740c48239b39">adjust_with_calibration</a> (<a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a> internal_target, <a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a> cinternal, <a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a> cexternal, <a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a> cnum, <a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a> cdenom)</td></tr>
<tr class="memdesc:af9d74523eb34b8702a27740c48239b39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the given <em>internal_target</em> clock time to the external time, using the passed calibration parameters.  <a href="#af9d74523eb34b8702a27740c48239b39">More...</a><br /></td></tr>
<tr class="separator:af9d74523eb34b8702a27740c48239b39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57e31b2b74b01255ee4860e634d9180c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Clock.html#a57e31b2b74b01255ee4860e634d9180c">unadjust_with_calibration</a> (<a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a> external_target, <a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a> cinternal, <a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a> cexternal, <a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a> cnum, <a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a> cdenom)</td></tr>
<tr class="memdesc:a57e31b2b74b01255ee4860e634d9180c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the given <em>external_target</em> clock time to the internal time, using the passed calibration parameters.  <a href="#a57e31b2b74b01255ee4860e634d9180c">More...</a><br /></td></tr>
<tr class="separator:a57e31b2b74b01255ee4860e634d9180c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af91b25e9735944f9004a58d278d7fbc9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Clock.html#af91b25e9735944f9004a58d278d7fbc9">get_calibration</a> (<a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a>&amp;<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01616.html#a084be990a1caf21a3b1ce38fe61bad3f">internal</a>, <a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a>&amp; external, <a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a>&amp; rate_num, <a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a>&amp; rate_denom) const</td></tr>
<tr class="memdesc:af91b25e9735944f9004a58d278d7fbc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the internal rate and reference time of <em>clock</em>.  <a href="#af91b25e9735944f9004a58d278d7fbc9">More...</a><br /></td></tr>
<tr class="separator:af91b25e9735944f9004a58d278d7fbc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12463def9152956a420fcebe24939f4f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Clock.html#a12463def9152956a420fcebe24939f4f">set_calibration</a> (<a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a> <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01616.html#a084be990a1caf21a3b1ce38fe61bad3f">internal</a>, <a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a> external, <a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a> rate_num, <a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a> rate_denom)</td></tr>
<tr class="memdesc:a12463def9152956a420fcebe24939f4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjusts the rate and time of <em>clock</em>.  <a href="#a12463def9152956a420fcebe24939f4f">More...</a><br /></td></tr>
<tr class="separator:a12463def9152956a420fcebe24939f4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab25f2d5423c487e02248733b819b9cad"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Clock.html#ab25f2d5423c487e02248733b819b9cad">wait_for_sync</a> (<a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a> timeout)</td></tr>
<tr class="memdesc:ab25f2d5423c487e02248733b819b9cad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits until <em>clock</em> is synced for reporting the current time.  <a href="#ab25f2d5423c487e02248733b819b9cad">More...</a><br /></td></tr>
<tr class="separator:ab25f2d5423c487e02248733b819b9cad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56dd59f66db560843fb1bbcdf4177cf3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Clock.html#a56dd59f66db560843fb1bbcdf4177cf3">is_synced</a> () const</td></tr>
<tr class="memdesc:a56dd59f66db560843fb1bbcdf4177cf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the clock is currently synced.  <a href="#a56dd59f66db560843fb1bbcdf4177cf3">More...</a><br /></td></tr>
<tr class="separator:a56dd59f66db560843fb1bbcdf4177cf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a585e591201ecd7f11f7a16ab5a549af8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Clock.html#a585e591201ecd7f11f7a16ab5a549af8">set_synced</a> (bool synced)</td></tr>
<tr class="memdesc:a585e591201ecd7f11f7a16ab5a549af8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <em>clock</em> to synced and emits the GstClock::synced signal, and wakes up any thread waiting in <a class="el" href="classGst_1_1Clock.html#ab25f2d5423c487e02248733b819b9cad" title="Waits until clock is synced for reporting the current time. ">wait_for_sync()</a>.  <a href="#a585e591201ecd7f11f7a16ab5a549af8">More...</a><br /></td></tr>
<tr class="separator:a585e591201ecd7f11f7a16ab5a549af8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3384c43f37681ab6d5cb4a859f1665cc"><td class="memItemLeft" align="right" valign="top">Glib::PropertyProxy&lt; guint64 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Clock.html#a3384c43f37681ab6d5cb4a859f1665cc">property_timeout</a> ()</td></tr>
<tr class="memdesc:a3384c43f37681ab6d5cb4a859f1665cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">get/set timeout can be achieved through 'timeout' property, so wrapping gst_clock_{get|set|_timeout is unnecessary.  <a href="#a3384c43f37681ab6d5cb4a859f1665cc">More...</a><br /></td></tr>
<tr class="separator:a3384c43f37681ab6d5cb4a859f1665cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa064dd76f12f488fea80e2f3350b2cf3"><td class="memItemLeft" align="right" valign="top">Glib::PropertyProxy_ReadOnly&lt; guint64 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Clock.html#aa064dd76f12f488fea80e2f3350b2cf3">property_timeout</a> () const</td></tr>
<tr class="memdesc:aa064dd76f12f488fea80e2f3350b2cf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The amount of time, in nanoseconds, to sample master and slave clocks.  <a href="#aa064dd76f12f488fea80e2f3350b2cf3">More...</a><br /></td></tr>
<tr class="separator:aa064dd76f12f488fea80e2f3350b2cf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03273877de11001166d9594fec12b423"><td class="memItemLeft" align="right" valign="top">Glib::PropertyProxy&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Clock.html#a03273877de11001166d9594fec12b423">property_window_size</a> ()</td></tr>
<tr class="memdesc:a03273877de11001166d9594fec12b423"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size of the window used to calculate rate and offset.  <a href="#a03273877de11001166d9594fec12b423">More...</a><br /></td></tr>
<tr class="separator:a03273877de11001166d9594fec12b423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a959ee0d9e7d79ba793e860a57077c17d"><td class="memItemLeft" align="right" valign="top">Glib::PropertyProxy_ReadOnly&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Clock.html#a959ee0d9e7d79ba793e860a57077c17d">property_window_size</a> () const</td></tr>
<tr class="memdesc:a959ee0d9e7d79ba793e860a57077c17d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size of the window used to calculate rate and offset.  <a href="#a959ee0d9e7d79ba793e860a57077c17d">More...</a><br /></td></tr>
<tr class="separator:a959ee0d9e7d79ba793e860a57077c17d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad405ca953c118dc54146d3d97a0d066f"><td class="memItemLeft" align="right" valign="top">Glib::PropertyProxy&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Clock.html#ad405ca953c118dc54146d3d97a0d066f">property_window_threshold</a> ()</td></tr>
<tr class="memdesc:ad405ca953c118dc54146d3d97a0d066f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The threshold to start calculating rate and offset.  <a href="#ad405ca953c118dc54146d3d97a0d066f">More...</a><br /></td></tr>
<tr class="separator:ad405ca953c118dc54146d3d97a0d066f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae2c7caf6770fea8e4d82f3ca1a54efb"><td class="memItemLeft" align="right" valign="top">Glib::PropertyProxy_ReadOnly&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Clock.html#aae2c7caf6770fea8e4d82f3ca1a54efb">property_window_threshold</a> () const</td></tr>
<tr class="memdesc:aae2c7caf6770fea8e4d82f3ca1a54efb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The threshold to start calculating rate and offset.  <a href="#aae2c7caf6770fea8e4d82f3ca1a54efb">More...</a><br /></td></tr>
<tr class="separator:aae2c7caf6770fea8e4d82f3ca1a54efb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add734cd91eba4da68639ebc4b80186ad"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Clock.html#add734cd91eba4da68639ebc4b80186ad">change_resolution_vfunc</a> (<a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a> old_resolution, <a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a> new_resolution)</td></tr>
<tr class="memdesc:add734cd91eba4da68639ebc4b80186ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the resolution of the clock.  <a href="#add734cd91eba4da68639ebc4b80186ad">More...</a><br /></td></tr>
<tr class="separator:add734cd91eba4da68639ebc4b80186ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a510a92b097c131fdbf516ce736dc14e7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Clock.html#a510a92b097c131fdbf516ce736dc14e7">get_resolution_vfunc</a> () const</td></tr>
<tr class="memdesc:a510a92b097c131fdbf516ce736dc14e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the resolution of the clock.  <a href="#a510a92b097c131fdbf516ce736dc14e7">More...</a><br /></td></tr>
<tr class="separator:a510a92b097c131fdbf516ce736dc14e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af38e834ae74307bd2c3c399d7a2814ce"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Clock.html#af38e834ae74307bd2c3c399d7a2814ce">get_internal_time_vfunc</a> () const</td></tr>
<tr class="memdesc:af38e834ae74307bd2c3c399d7a2814ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the internal unadjusted time of the clock.  <a href="#af38e834ae74307bd2c3c399d7a2814ce">More...</a><br /></td></tr>
<tr class="separator:af38e834ae74307bd2c3c399d7a2814ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add60e95e1f185910dfacfa17fc5a63a8"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__gstreamermmEnums.html#gaa501f23d690de389e755e652093d9392">ClockReturn</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Clock.html#add60e95e1f185910dfacfa17fc5a63a8">wait_vfunc</a> (const Glib::RefPtr&lt; <a class="el" href="classGst_1_1ClockID.html">Gst::ClockID</a> &gt;&amp; id, <a class="el" href="namespaceGst.html#a1bd878eb666682156ef268a6ff0ad16c">Gst::ClockTimeDiff</a>&amp; jitter)</td></tr>
<tr class="memdesc:add60e95e1f185910dfacfa17fc5a63a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a blocking wait for the given <a class="el" href="classGst_1_1ClockID.html" title="A data type to hold the handle to an outstanding sync or async clock callback. ">Gst::ClockID</a>.  <a href="#add60e95e1f185910dfacfa17fc5a63a8">More...</a><br /></td></tr>
<tr class="separator:add60e95e1f185910dfacfa17fc5a63a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5f4d706cab453f51c822f2abf4bde12"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__gstreamermmEnums.html#gaa501f23d690de389e755e652093d9392">ClockReturn</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Clock.html#ae5f4d706cab453f51c822f2abf4bde12">wait_async_vfunc</a> (const Glib::RefPtr&lt; <a class="el" href="classGst_1_1ClockID.html">Gst::ClockID</a> &gt;&amp; id)</td></tr>
<tr class="memdesc:ae5f4d706cab453f51c822f2abf4bde12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform an asynchronous wait for the given <a class="el" href="classGst_1_1ClockID.html" title="A data type to hold the handle to an outstanding sync or async clock callback. ">Gst::ClockID</a>.  <a href="#ae5f4d706cab453f51c822f2abf4bde12">More...</a><br /></td></tr>
<tr class="separator:ae5f4d706cab453f51c822f2abf4bde12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc41eb372e0f7b1ad9071f53ba668eeb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Clock.html#abc41eb372e0f7b1ad9071f53ba668eeb">unschedule_vfunc</a> (const Glib::RefPtr&lt; <a class="el" href="classGst_1_1ClockID.html">Gst::ClockID</a> &gt;&amp; id)</td></tr>
<tr class="memdesc:abc41eb372e0f7b1ad9071f53ba668eeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unblock a blocking or async wait operation.  <a href="#abc41eb372e0f7b1ad9071f53ba668eeb">More...</a><br /></td></tr>
<tr class="separator:abc41eb372e0f7b1ad9071f53ba668eeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af611b1720354f8c3c553e2d819cea002"><td class="memItemLeft" align="right" valign="top">Glib::SignalProxy&lt; void, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Clock.html#af611b1720354f8c3c553e2d819cea002">signal_synced</a> ()</td></tr>
<tr class="separator:af611b1720354f8c3c553e2d819cea002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classGst_1_1Object"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classGst_1_1Object')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classGst_1_1Object.html">Gst::Object</a></td></tr>
<tr class="memitem:a81151161e4abf313e76ab35fa73d1293 inherit pub_methods_classGst_1_1Object"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Object.html#a81151161e4abf313e76ab35fa73d1293">Object</a> (<a class="el" href="classGst_1_1Object.html">Object</a>&amp;&amp; src) noexcept</td></tr>
<tr class="separator:a81151161e4abf313e76ab35fa73d1293 inherit pub_methods_classGst_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3b8964b21574cae10f31d80061c7e40 inherit pub_methods_classGst_1_1Object"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGst_1_1Object.html">Object</a>&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Object.html#af3b8964b21574cae10f31d80061c7e40">operator=</a> (<a class="el" href="classGst_1_1Object.html">Object</a>&amp;&amp; src) noexcept</td></tr>
<tr class="separator:af3b8964b21574cae10f31d80061c7e40 inherit pub_methods_classGst_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4ecd638aea2e21916e2e21429eef97a inherit pub_methods_classGst_1_1Object"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Object.html#ad4ecd638aea2e21916e2e21429eef97a">~Object</a> () noexcept override</td></tr>
<tr class="separator:ad4ecd638aea2e21916e2e21429eef97a inherit pub_methods_classGst_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d889e949c76aa3ab4490026d6aca8ca inherit pub_methods_classGst_1_1Object"><td class="memItemLeft" align="right" valign="top">GstObject*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Object.html#a3d889e949c76aa3ab4490026d6aca8ca">gobj</a> ()</td></tr>
<tr class="memdesc:a3d889e949c76aa3ab4490026d6aca8ca inherit pub_methods_classGst_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the underlying C GObject.  <a href="classGst_1_1Object.html#a3d889e949c76aa3ab4490026d6aca8ca">More...</a><br /></td></tr>
<tr class="separator:a3d889e949c76aa3ab4490026d6aca8ca inherit pub_methods_classGst_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6a4514f948551dcc2e45b3636b490fe inherit pub_methods_classGst_1_1Object"><td class="memItemLeft" align="right" valign="top">const GstObject*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Object.html#ad6a4514f948551dcc2e45b3636b490fe">gobj</a> () const</td></tr>
<tr class="memdesc:ad6a4514f948551dcc2e45b3636b490fe inherit pub_methods_classGst_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the underlying C GObject.  <a href="classGst_1_1Object.html#ad6a4514f948551dcc2e45b3636b490fe">More...</a><br /></td></tr>
<tr class="separator:ad6a4514f948551dcc2e45b3636b490fe inherit pub_methods_classGst_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63d7202d3eb47c81ffc3ac16a895e9d1 inherit pub_methods_classGst_1_1Object"><td class="memItemLeft" align="right" valign="top">GstObject*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Object.html#a63d7202d3eb47c81ffc3ac16a895e9d1">gobj_copy</a> ()</td></tr>
<tr class="memdesc:a63d7202d3eb47c81ffc3ac16a895e9d1 inherit pub_methods_classGst_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the underlying C instance. The caller is responsible for unrefing it. Use when directly setting fields in structs.  <a href="classGst_1_1Object.html#a63d7202d3eb47c81ffc3ac16a895e9d1">More...</a><br /></td></tr>
<tr class="separator:a63d7202d3eb47c81ffc3ac16a895e9d1 inherit pub_methods_classGst_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae96d8781fb1614a5a97e2a6f39e823b3 inherit pub_methods_classGst_1_1Object"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Object.html#ae96d8781fb1614a5a97e2a6f39e823b3">is_element</a> () const</td></tr>
<tr class="separator:ae96d8781fb1614a5a97e2a6f39e823b3 inherit pub_methods_classGst_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a906d1bd351d5f20a38964d6ab9a2c845 inherit pub_methods_classGst_1_1Object"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Object.html#a906d1bd351d5f20a38964d6ab9a2c845">is_element_factory</a> () const</td></tr>
<tr class="separator:a906d1bd351d5f20a38964d6ab9a2c845 inherit pub_methods_classGst_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb1cbea0f958a71af207f46d8b4ff5fc inherit pub_methods_classGst_1_1Object"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Object.html#acb1cbea0f958a71af207f46d8b4ff5fc">is_pad</a> () const</td></tr>
<tr class="separator:acb1cbea0f958a71af207f46d8b4ff5fc inherit pub_methods_classGst_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b577e25de7574fa1c0b98db8072bc47 inherit pub_methods_classGst_1_1Object"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Object.html#a8b577e25de7574fa1c0b98db8072bc47">is_pad_template</a> () const</td></tr>
<tr class="separator:a8b577e25de7574fa1c0b98db8072bc47 inherit pub_methods_classGst_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc51ab9f7e9c1b002502bcbcb747fa78 inherit pub_methods_classGst_1_1Object"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Object.html#afc51ab9f7e9c1b002502bcbcb747fa78">is_bin</a> () const</td></tr>
<tr class="separator:afc51ab9f7e9c1b002502bcbcb747fa78 inherit pub_methods_classGst_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac824b4d7a69a1068ed3614c8c0bdd24 inherit pub_methods_classGst_1_1Object"><td class="memItemLeft" align="right" valign="top">guint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Object.html#aac824b4d7a69a1068ed3614c8c0bdd24">get_flags</a> () const</td></tr>
<tr class="memdesc:aac824b4d7a69a1068ed3614c8c0bdd24 inherit pub_methods_classGst_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the entire set of flags for the object.  <a href="classGst_1_1Object.html#aac824b4d7a69a1068ed3614c8c0bdd24">More...</a><br /></td></tr>
<tr class="separator:aac824b4d7a69a1068ed3614c8c0bdd24 inherit pub_methods_classGst_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91745b6c35472bc28fde65c770444478 inherit pub_methods_classGst_1_1Object"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Object.html#a91745b6c35472bc28fde65c770444478">set_name</a> (const Glib::ustring&amp; name)</td></tr>
<tr class="memdesc:a91745b6c35472bc28fde65c770444478 inherit pub_methods_classGst_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the name of <em>object</em>, or gives <em>object</em> a guaranteed unique name (if <em>name</em> is <code>nullptr</code>).  <a href="classGst_1_1Object.html#a91745b6c35472bc28fde65c770444478">More...</a><br /></td></tr>
<tr class="separator:a91745b6c35472bc28fde65c770444478 inherit pub_methods_classGst_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8a7e72f2bf6539244668d7238d46159 inherit pub_methods_classGst_1_1Object"><td class="memItemLeft" align="right" valign="top">Glib::ustring&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Object.html#ab8a7e72f2bf6539244668d7238d46159">get_name</a> () const</td></tr>
<tr class="memdesc:ab8a7e72f2bf6539244668d7238d46159 inherit pub_methods_classGst_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the name of <em>object</em>.  <a href="classGst_1_1Object.html#ab8a7e72f2bf6539244668d7238d46159">More...</a><br /></td></tr>
<tr class="separator:ab8a7e72f2bf6539244668d7238d46159 inherit pub_methods_classGst_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09a2f2fcfb0fabee2597b34a0b7c3fe4 inherit pub_methods_classGst_1_1Object"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Object.html#a09a2f2fcfb0fabee2597b34a0b7c3fe4">set_parent</a> (const Glib::RefPtr&lt; <a class="el" href="classGst_1_1Object.html">Gst::Object</a> &gt;&amp; parent)</td></tr>
<tr class="memdesc:a09a2f2fcfb0fabee2597b34a0b7c3fe4 inherit pub_methods_classGst_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the parent of <em>object</em> to <em>parent</em>.  <a href="classGst_1_1Object.html#a09a2f2fcfb0fabee2597b34a0b7c3fe4">More...</a><br /></td></tr>
<tr class="separator:a09a2f2fcfb0fabee2597b34a0b7c3fe4 inherit pub_methods_classGst_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a303610665c252f733808e5653703f6a8 inherit pub_methods_classGst_1_1Object"><td class="memItemLeft" align="right" valign="top">Glib::RefPtr&lt; <a class="el" href="classGst_1_1Object.html">Gst::Object</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Object.html#a303610665c252f733808e5653703f6a8">get_parent</a> ()</td></tr>
<tr class="memdesc:a303610665c252f733808e5653703f6a8 inherit pub_methods_classGst_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the parent of <em>object</em>.  <a href="classGst_1_1Object.html#a303610665c252f733808e5653703f6a8">More...</a><br /></td></tr>
<tr class="separator:a303610665c252f733808e5653703f6a8 inherit pub_methods_classGst_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f8dc04241bee2beb2e3b8e0887bf240 inherit pub_methods_classGst_1_1Object"><td class="memItemLeft" align="right" valign="top">Glib::RefPtr&lt; const <a class="el" href="classGst_1_1Object.html">Gst::Object</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Object.html#a8f8dc04241bee2beb2e3b8e0887bf240">get_parent</a> () const</td></tr>
<tr class="memdesc:a8f8dc04241bee2beb2e3b8e0887bf240 inherit pub_methods_classGst_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the parent of <em>object</em>.  <a href="classGst_1_1Object.html#a8f8dc04241bee2beb2e3b8e0887bf240">More...</a><br /></td></tr>
<tr class="separator:a8f8dc04241bee2beb2e3b8e0887bf240 inherit pub_methods_classGst_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45b87529c337e40f03e34bca450e41bc inherit pub_methods_classGst_1_1Object"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Object.html#a45b87529c337e40f03e34bca450e41bc">unparent</a> ()</td></tr>
<tr class="memdesc:a45b87529c337e40f03e34bca450e41bc inherit pub_methods_classGst_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the parent of <em>object</em>, removing the associated reference.  <a href="classGst_1_1Object.html#a45b87529c337e40f03e34bca450e41bc">More...</a><br /></td></tr>
<tr class="separator:a45b87529c337e40f03e34bca450e41bc inherit pub_methods_classGst_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71dd4f21c9c28e44bbb102d4020d6fb9 inherit pub_methods_classGst_1_1Object"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Object.html#a71dd4f21c9c28e44bbb102d4020d6fb9">set_control_rate</a> (<a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a> control_rate)</td></tr>
<tr class="memdesc:a71dd4f21c9c28e44bbb102d4020d6fb9 inherit pub_methods_classGst_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the control-rate for this <em>object</em>.  <a href="classGst_1_1Object.html#a71dd4f21c9c28e44bbb102d4020d6fb9">More...</a><br /></td></tr>
<tr class="separator:a71dd4f21c9c28e44bbb102d4020d6fb9 inherit pub_methods_classGst_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f61c7a77c8915f25ea9630e316e64d1 inherit pub_methods_classGst_1_1Object"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Object.html#a0f61c7a77c8915f25ea9630e316e64d1">get_control_rate</a> () const</td></tr>
<tr class="memdesc:a0f61c7a77c8915f25ea9630e316e64d1 inherit pub_methods_classGst_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the control-rate for this <em>object</em>.  <a href="classGst_1_1Object.html#a0f61c7a77c8915f25ea9630e316e64d1">More...</a><br /></td></tr>
<tr class="separator:a0f61c7a77c8915f25ea9630e316e64d1 inherit pub_methods_classGst_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ecaa24f220031816a05cd2f332e5149 inherit pub_methods_classGst_1_1Object"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Object.html#a6ecaa24f220031816a05cd2f332e5149">suggest_next_sync</a> () const</td></tr>
<tr class="memdesc:a6ecaa24f220031816a05cd2f332e5149 inherit pub_methods_classGst_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a suggestion for timestamps where buffers should be split to get best controller results.  <a href="classGst_1_1Object.html#a6ecaa24f220031816a05cd2f332e5149">More...</a><br /></td></tr>
<tr class="separator:a6ecaa24f220031816a05cd2f332e5149 inherit pub_methods_classGst_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ffd67bd304da65bec7966e0618318fa inherit pub_methods_classGst_1_1Object"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Object.html#a1ffd67bd304da65bec7966e0618318fa">sync_values</a> (<a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a> timestamp)</td></tr>
<tr class="memdesc:a1ffd67bd304da65bec7966e0618318fa inherit pub_methods_classGst_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the properties of the object, according to the Gst::ControlSources that (maybe) handle them and for the given timestamp.  <a href="classGst_1_1Object.html#a1ffd67bd304da65bec7966e0618318fa">More...</a><br /></td></tr>
<tr class="separator:a1ffd67bd304da65bec7966e0618318fa inherit pub_methods_classGst_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50cf4988393c9a170d196640f4e57384 inherit pub_methods_classGst_1_1Object"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Object.html#a50cf4988393c9a170d196640f4e57384">set_control_bindings_disabled</a> (bool disabled)</td></tr>
<tr class="memdesc:a50cf4988393c9a170d196640f4e57384 inherit pub_methods_classGst_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to disable all controlled properties of the <em>object</em> for some time, i.e. <a class="el" href="classGst_1_1Object.html#a1ffd67bd304da65bec7966e0618318fa" title="Sets the properties of the object, according to the Gst::ControlSources that (maybe) handle them and ...">sync_values()</a> will do nothing.  <a href="classGst_1_1Object.html#a50cf4988393c9a170d196640f4e57384">More...</a><br /></td></tr>
<tr class="separator:a50cf4988393c9a170d196640f4e57384 inherit pub_methods_classGst_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7802f29724a1d24e9b317793c58d4b10 inherit pub_methods_classGst_1_1Object"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Object.html#a7802f29724a1d24e9b317793c58d4b10">has_asctive_control_bindings</a> () const</td></tr>
<tr class="memdesc:a7802f29724a1d24e9b317793c58d4b10 inherit pub_methods_classGst_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classGst_1_1Check.html">Check</a> if the <em>object</em> has an active controlled properties.  <a href="classGst_1_1Object.html#a7802f29724a1d24e9b317793c58d4b10">More...</a><br /></td></tr>
<tr class="separator:a7802f29724a1d24e9b317793c58d4b10 inherit pub_methods_classGst_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee1a36004d2f70fcafb2a69a10c9bae6 inherit pub_methods_classGst_1_1Object"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Object.html#aee1a36004d2f70fcafb2a69a10c9bae6">has_ancestor</a> (const Glib::RefPtr&lt; const <a class="el" href="classGst_1_1Object.html">Gst::Object</a> &gt;&amp; ancestor) const</td></tr>
<tr class="memdesc:aee1a36004d2f70fcafb2a69a10c9bae6 inherit pub_methods_classGst_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classGst_1_1Check.html">Check</a> if <em>object</em> has an ancestor <em>ancestor</em> somewhere up in the hierarchy.  <a href="classGst_1_1Object.html#aee1a36004d2f70fcafb2a69a10c9bae6">More...</a><br /></td></tr>
<tr class="separator:aee1a36004d2f70fcafb2a69a10c9bae6 inherit pub_methods_classGst_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e8abe2e2e7cda5b26ee7a7e52320890 inherit pub_methods_classGst_1_1Object"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Object.html#a4e8abe2e2e7cda5b26ee7a7e52320890">has_as_ancestor</a> (const Glib::RefPtr&lt; <a class="el" href="classGst_1_1Object.html">Gst::Object</a> &gt;&amp; ancestor) const</td></tr>
<tr class="memdesc:a4e8abe2e2e7cda5b26ee7a7e52320890 inherit pub_methods_classGst_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classGst_1_1Check.html">Check</a> if <em>object</em> has an ancestor <em>ancestor</em> somewhere up in the hierarchy.  <a href="classGst_1_1Object.html#a4e8abe2e2e7cda5b26ee7a7e52320890">More...</a><br /></td></tr>
<tr class="separator:a4e8abe2e2e7cda5b26ee7a7e52320890 inherit pub_methods_classGst_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaaa4fbe4078d9ceadd45435ed0f079d inherit pub_methods_classGst_1_1Object"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Object.html#abaaa4fbe4078d9ceadd45435ed0f079d">has_as_parent</a> (const Glib::RefPtr&lt; <a class="el" href="classGst_1_1Object.html">Gst::Object</a> &gt;&amp; parent) const</td></tr>
<tr class="memdesc:abaaa4fbe4078d9ceadd45435ed0f079d inherit pub_methods_classGst_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classGst_1_1Check.html">Check</a> if <em>parent</em> is the parent of <em>object</em>.  <a href="classGst_1_1Object.html#abaaa4fbe4078d9ceadd45435ed0f079d">More...</a><br /></td></tr>
<tr class="separator:abaaa4fbe4078d9ceadd45435ed0f079d inherit pub_methods_classGst_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e2da47b8e8eb7c48e6e6ec1a4f6ac94 inherit pub_methods_classGst_1_1Object"><td class="memItemLeft" align="right" valign="top">Glib::ustring&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Object.html#a4e2da47b8e8eb7c48e6e6ec1a4f6ac94">get_path_string</a> ()</td></tr>
<tr class="memdesc:a4e2da47b8e8eb7c48e6e6ec1a4f6ac94 inherit pub_methods_classGst_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a string describing the path of <em>object</em> in the object hierarchy.  <a href="classGst_1_1Object.html#a4e2da47b8e8eb7c48e6e6ec1a4f6ac94">More...</a><br /></td></tr>
<tr class="separator:a4e2da47b8e8eb7c48e6e6ec1a4f6ac94 inherit pub_methods_classGst_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d51c0f61b8ef58eafb2a2f2e59b1f74 inherit pub_methods_classGst_1_1Object"><td class="memItemLeft" align="right" valign="top">Glib::PropertyProxy&lt; Glib::ustring &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Object.html#a3d51c0f61b8ef58eafb2a2f2e59b1f74">property_name</a> ()</td></tr>
<tr class="memdesc:a3d51c0f61b8ef58eafb2a2f2e59b1f74 inherit pub_methods_classGst_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">The name of the object.  <a href="classGst_1_1Object.html#a3d51c0f61b8ef58eafb2a2f2e59b1f74">More...</a><br /></td></tr>
<tr class="separator:a3d51c0f61b8ef58eafb2a2f2e59b1f74 inherit pub_methods_classGst_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf94eb5a427a1e7d2907caf50a8cf7e2 inherit pub_methods_classGst_1_1Object"><td class="memItemLeft" align="right" valign="top">Glib::PropertyProxy_ReadOnly&lt; Glib::ustring &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Object.html#adf94eb5a427a1e7d2907caf50a8cf7e2">property_name</a> () const</td></tr>
<tr class="memdesc:adf94eb5a427a1e7d2907caf50a8cf7e2 inherit pub_methods_classGst_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">The name of the object.  <a href="classGst_1_1Object.html#adf94eb5a427a1e7d2907caf50a8cf7e2">More...</a><br /></td></tr>
<tr class="separator:adf94eb5a427a1e7d2907caf50a8cf7e2 inherit pub_methods_classGst_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73a0272f16e1481f54150b1b412fa88c inherit pub_methods_classGst_1_1Object"><td class="memItemLeft" align="right" valign="top">Glib::PropertyProxy&lt; Glib::RefPtr&lt; <a class="el" href="classGst_1_1Object.html">Gst::Object</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Object.html#a73a0272f16e1481f54150b1b412fa88c">property_parent</a> ()</td></tr>
<tr class="memdesc:a73a0272f16e1481f54150b1b412fa88c inherit pub_methods_classGst_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">The parent of the object.  <a href="classGst_1_1Object.html#a73a0272f16e1481f54150b1b412fa88c">More...</a><br /></td></tr>
<tr class="separator:a73a0272f16e1481f54150b1b412fa88c inherit pub_methods_classGst_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa675064df0fcf0aaee34db75b8a6005b inherit pub_methods_classGst_1_1Object"><td class="memItemLeft" align="right" valign="top">Glib::PropertyProxy_ReadOnly&lt; Glib::RefPtr&lt; <a class="el" href="classGst_1_1Object.html">Gst::Object</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Object.html#aa675064df0fcf0aaee34db75b8a6005b">property_parent</a> () const</td></tr>
<tr class="memdesc:aa675064df0fcf0aaee34db75b8a6005b inherit pub_methods_classGst_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">The parent of the object.  <a href="classGst_1_1Object.html#aa675064df0fcf0aaee34db75b8a6005b">More...</a><br /></td></tr>
<tr class="separator:aa675064df0fcf0aaee34db75b8a6005b inherit pub_methods_classGst_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0fe96dbc1176a937bdb829ad3334afb inherit pub_methods_classGst_1_1Object"><td class="memItemLeft" align="right" valign="top">Glib::SignalProxy&lt; void, const Glib::RefPtr&lt; <a class="el" href="classGst_1_1Object.html">Gst::Object</a> &gt;&amp;, GParamSpec*&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Object.html#ac0fe96dbc1176a937bdb829ad3334afb">signal_deep_notify</a> ()</td></tr>
<tr class="separator:ac0fe96dbc1176a937bdb829ad3334afb inherit pub_methods_classGst_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc2d69664a0d2bc0176e3421ff4b351f inherit pub_methods_classGst_1_1Object"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Object.html#afc2d69664a0d2bc0176e3421ff4b351f">get_refcount</a> () const</td></tr>
<tr class="separator:afc2d69664a0d2bc0176e3421ff4b351f inherit pub_methods_classGst_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ab84fc422b0572b71504a4646384b2b84"><td class="memItemLeft" align="right" valign="top">static GType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Clock.html#ab84fc422b0572b71504a4646384b2b84">get_type</a> ()</td></tr>
<tr class="memdesc:ab84fc422b0572b71504a4646384b2b84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the GType for this class, for use with the underlying GObject type system.  <a href="#ab84fc422b0572b71504a4646384b2b84">More...</a><br /></td></tr>
<tr class="separator:ab84fc422b0572b71504a4646384b2b84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classGst_1_1Object"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classGst_1_1Object')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classGst_1_1Object.html">Gst::Object</a></td></tr>
<tr class="memitem:a8d7dfcf69a7c5c6086ab8149626fffcd inherit pub_static_methods_classGst_1_1Object"><td class="memItemLeft" align="right" valign="top">static GType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Object.html#a8d7dfcf69a7c5c6086ab8149626fffcd">get_type</a> ()</td></tr>
<tr class="memdesc:a8d7dfcf69a7c5c6086ab8149626fffcd inherit pub_static_methods_classGst_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the GType for this class, for use with the underlying GObject type system.  <a href="classGst_1_1Object.html#a8d7dfcf69a7c5c6086ab8149626fffcd">More...</a><br /></td></tr>
<tr class="separator:a8d7dfcf69a7c5c6086ab8149626fffcd inherit pub_static_methods_classGst_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a036969c9ee33ffe4270c2ceec02222a6 inherit pub_static_methods_classGst_1_1Object"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Object.html#a036969c9ee33ffe4270c2ceec02222a6">check_uniqueness</a> (const Glib::ListHandle&lt; const <a class="el" href="classGst_1_1Object.html">Gst::Object</a> &gt;&amp; list, const Glib::ustring&amp; name)</td></tr>
<tr class="memdesc:a036969c9ee33ffe4270c2ceec02222a6 inherit pub_static_methods_classGst_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if there is any object named <em>name</em> in <em>list</em>.  <a href="classGst_1_1Object.html#a036969c9ee33ffe4270c2ceec02222a6">More...</a><br /></td></tr>
<tr class="separator:a036969c9ee33ffe4270c2ceec02222a6 inherit pub_static_methods_classGst_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:aa055df9465a22ca8144c637617a3fea9"><td class="memItemLeft" align="right" valign="top">Glib::RefPtr&lt; <a class="el" href="classGst_1_1Clock.html">Gst::Clock</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Clock.html#aa055df9465a22ca8144c637617a3fea9">wrap</a> (GstClock* object, bool take_copy=false)</td></tr>
<tr class="memdesc:aa055df9465a22ca8144c637617a3fea9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="namespaceGlib.html#a43fcab2a44083e8b7b6a1c8193acae2b">Glib::wrap()</a> method for this object.  <a href="#aa055df9465a22ca8144c637617a3fea9">More...</a><br /></td></tr>
<tr class="separator:aa055df9465a22ca8144c637617a3fea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header related_classGst_1_1Object"><td colspan="2" onclick="javascript:toggleInherit('related_classGst_1_1Object')"><img src="closed.png" alt="-"/>&#160;Related Functions inherited from <a class="el" href="classGst_1_1Object.html">Gst::Object</a></td></tr>
<tr class="memitem:a78a831adab0d01760dd9cddec10f8986 inherit related_classGst_1_1Object"><td class="memItemLeft" align="right" valign="top">Glib::RefPtr&lt; <a class="el" href="classGst_1_1Object.html">Gst::Object</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Object.html#a78a831adab0d01760dd9cddec10f8986">wrap</a> (GstObject* object, bool take_copy=false)</td></tr>
<tr class="memdesc:a78a831adab0d01760dd9cddec10f8986 inherit related_classGst_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="namespaceGlib.html#a43fcab2a44083e8b7b6a1c8193acae2b">Glib::wrap()</a> method for this object.  <a href="classGst_1_1Object.html#a78a831adab0d01760dd9cddec10f8986">More...</a><br /></td></tr>
<tr class="separator:a78a831adab0d01760dd9cddec10f8986 inherit related_classGst_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_classGst_1_1Object"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classGst_1_1Object')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classGst_1_1Object.html">Gst::Object</a></td></tr>
<tr class="memitem:a133db3a4c137e5cc57227edb343d6fdb inherit pro_methods_classGst_1_1Object"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Object.html#a133db3a4c137e5cc57227edb343d6fdb">on_deep_notify</a> (const Glib::RefPtr&lt; <a class="el" href="classGst_1_1Object.html">Gst::Object</a> &gt;&amp; prop_object, GParamSpec* prop)</td></tr>
<tr class="memdesc:a133db3a4c137e5cc57227edb343d6fdb inherit pro_methods_classGst_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a default handler for the signal <a class="el" href="classGst_1_1Object.html#ac0fe96dbc1176a937bdb829ad3334afb">signal_deep_notify()</a>.  <a href="classGst_1_1Object.html#a133db3a4c137e5cc57227edb343d6fdb">More...</a><br /></td></tr>
<tr class="separator:a133db3a4c137e5cc57227edb343d6fdb inherit pro_methods_classGst_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Abstract class for global clocks GStreamer uses a global clock to synchronize the plugins in a pipeline. </p>
<p>Different clock implementations are possible by implementing this abstract base class.</p>
<p>The <a class="el" href="classGst_1_1Clock.html" title="Abstract class for global clocks GStreamer uses a global clock to synchronize the plugins in a pipeli...">Gst::Clock</a> returns a monotonically increasing time with the method <a class="el" href="classGst_1_1Clock.html#af263ed436ab5f105f1e6cc71243ed65e" title="Gets the current time of the given clock. ">get_time()</a>. Its accuracy and base time depend on the specific clock implementation but time is always expressed in nanoseconds. Since the baseline of the clock is undefined, the clock time returned is not meaningful in itself, what matters are the deltas between two clock times. The time returned by a clock is called the absolute time.</p>
<p>The pipeline uses the clock to calculate the running time. Usually all renderers synchronize to the global clock using the buffer timestamps, the newsegment events and the element's base time, see <a class="el" href="classGst_1_1Pipeline.html" title="A top-level bin with clocking and bus management functionality. ">Gst::Pipeline</a>.</p>
<p>A clock implementation can support periodic and single shot clock notifications both synchronous and asynchronous.</p>
<p>One first needs to create a <a class="el" href="classGst_1_1ClockID.html" title="A data type to hold the handle to an outstanding sync or async clock callback. ">Gst::ClockID</a> for the periodic or single shot notification using <a class="el" href="classGst_1_1Clock.html#ae5d5e8edfe6254d46c9ae6a7063fa3cd" title="Get a Gst::ClockID from clock to trigger a single shot notification at the requested time...">create_single_shot_id()</a> or <a class="el" href="classGst_1_1Clock.html#ad82c3164cea026acbc4b7bc797502ad9" title="Get an ID from clock to trigger a periodic notification. ">create_periodic_id()</a>.</p>
<p>To perform a blocking wait for the specific time of the <a class="el" href="classGst_1_1ClockID.html" title="A data type to hold the handle to an outstanding sync or async clock callback. ">Gst::ClockID</a> use the <a class="el" href="classGst_1_1ClockID.html#ad11cfa71447a9365364ee3e63b3bcd4b" title="A wait() convenience overload. ">Gst::ClockID::wait()</a>. To receive a callback when the specific time is reached in the clock use <a class="el" href="classGst_1_1ClockID.html#a05351f52919ad9a36743f59848e74c28" title="Register a slot on the given Gst::ClockID id with the given slot. ">Gst::ClockID::wait_async()</a>. Both these calls can be interrupted with the <a class="el" href="classGst_1_1ClockID.html#aac9b66d4c3632a5f2c7bc3a1975cfded" title="Cancel an outstanding request with id. ">Gst::ClockID::unschedule()</a> call. If the blocking wait is unscheduled a return value of <a class="el" href="namespaceGst.html#gaa501f23d690de389e755e652093d9392a839aedd452083679a18cbde705761564" title="The clockID was unscheduled. ">Gst::CLOCK_UNSCHEDULED</a> is returned.</p>
<p>Periodic callbacks scheduled async will be repeatedly called automatically until it is unscheduled. To schedule a sync periodic callback, <a class="el" href="classGst_1_1ClockID.html#ad11cfa71447a9365364ee3e63b3bcd4b" title="A wait() convenience overload. ">Gst::ClockID::wait()</a> should be called repeatedly.</p>
<p>The async callbacks can happen from any thread, either provided by the core or from a streaming thread. The application should be prepared for this.</p>
<p>A <a class="el" href="classGst_1_1ClockID.html" title="A data type to hold the handle to an outstanding sync or async clock callback. ">Gst::ClockID</a> that has been unscheduled cannot be used again for any wait operation, a new <a class="el" href="classGst_1_1ClockID.html" title="A data type to hold the handle to an outstanding sync or async clock callback. ">Gst::ClockID</a> should be created.</p>
<p>It is possible to perform a blocking wait on the same <a class="el" href="classGst_1_1ClockID.html" title="A data type to hold the handle to an outstanding sync or async clock callback. ">Gst::ClockID</a> from multiple threads. However, registering the same <a class="el" href="classGst_1_1ClockID.html" title="A data type to hold the handle to an outstanding sync or async clock callback. ">Gst::ClockID</a> for multiple async notifications is not possible, the callback will only be called for the thread registering the entry last.</p>
<p>None of the wait operations unref the <a class="el" href="classGst_1_1ClockID.html" title="A data type to hold the handle to an outstanding sync or async clock callback. ">Gst::ClockID</a>, the owner is responsible for unreffing the ids itself. This holds for both periodic and single shot notifications. The reason being that the owner of the <a class="el" href="classGst_1_1ClockID.html" title="A data type to hold the handle to an outstanding sync or async clock callback. ">Gst::ClockID</a> has to keep a handle to the <a class="el" href="classGst_1_1ClockID.html" title="A data type to hold the handle to an outstanding sync or async clock callback. ">Gst::ClockID</a> to unblock the wait on FLUSHING events or state changes and if the entry would be unreffed automatically, the handle might become invalid without any notification. (The RefPtr takes care of</p><ul>
<li><p class="startli">* unreffing in this case)</p>
<p class="startli">These clock operations do not operate on the running time, so the callbacks will also occur when not in PLAYING state as if the clock just keeps on running. Some clocks however do not progress when the element that provided the clock is not PLAYING.</p>
<p class="startli">When a clock has the <a class="el" href="namespaceGst.html#gae4cd01977bbec7f009fb9725d8cfa080ae305a77c17a6fc0d404e4c8fcbea27c3" title="Clock can be slaved to a master clock. ">Gst::CLOCK_FLAG_CAN_SET_MASTER</a> flag set, it can be slaved to another <a class="el" href="classGst_1_1Clock.html" title="Abstract class for global clocks GStreamer uses a global clock to synchronize the plugins in a pipeli...">Gst::Clock</a> with the <a class="el" href="classGst_1_1Clock.html#ab85ebe6e289302d83738ccd55bbfe4b6" title="Set master_clock as the master clock for clock. ">set_master()</a>. The clock will then automatically be synchronized to this master clock by repeatedly sampling the master clock and the slave clock and recalibrating the slave clock with <a class="el" href="classGst_1_1Clock.html#a12463def9152956a420fcebe24939f4f" title="Adjusts the rate and time of clock. ">set_calibration()</a>. This feature is mostly useful for plugins that have an internal clock but must operate with another clock selected by the <a class="el" href="classGst_1_1Pipeline.html" title="A top-level bin with clocking and bus management functionality. ">Gst::Pipeline</a>. They can track the offset and rate difference of their internal clock relative to the master clock by using the <a class="el" href="classGst_1_1Clock.html#af91b25e9735944f9004a58d278d7fbc9" title="Gets the internal rate and reference time of clock. ">get_calibration()</a> method.</p>
<p class="startli">The master/slave synchronisation can be tuned with the "timeout", "window-size" and "window-threshold" properties. The "timeout" property defines the interval to sample the master clock and run the calibration functions. "window-size" defines the number of samples to use when calibrating and "window-threshold" defines the minimum number of samples before the calibration is performed.</p>
<p class="startli">Last reviewed on 2016-05-16 (1.8.0) </p>
</li>
</ul>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a1b9f5dc210f002c6fb4a62b13cfcb0b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b9f5dc210f002c6fb4a62b13cfcb0b8">&#9670;&#160;</a></span>Clock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Gst::Clock::Clock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGst_1_1Clock.html">Clock</a>&amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac9e465fc7ec0a9406fb8d9017ddbd67d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9e465fc7ec0a9406fb8d9017ddbd67d">&#9670;&#160;</a></span>~Clock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Gst::Clock::~Clock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa76795d0374dc653b3b31d58652124be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa76795d0374dc653b3b31d58652124be">&#9670;&#160;</a></span>add_observation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gst::Clock::add_observation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a>&#160;</td>
          <td class="paramname"><em>slave_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a>&#160;</td>
          <td class="paramname"><em>master_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gdouble &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The time <em>master_time</em> of the master clock and the time <em>slave_time</em> of the slave clock are added to the list of observations. </p>
<p>If enough observations are available, a linear regression algorithm is run on the observations and <em>clock</em> is recalibrated.</p>
<p>If this functions returns <code>true</code>, <em>result</em> will contain the correlation coefficient of the interpolation. A value of 1.0 means a perfect regression was performed. This value can be used to control the sampling frequency of the master and slave clocks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slave_time</td><td>A time on the slave. </td></tr>
    <tr><td class="paramname">master_time</td><td>A time on the master. </td></tr>
    <tr><td class="paramname">result</td><td>A pointer to hold the result. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if enough observations were added to run the regression algorithm.</dd></dl>
<p>MT safe. </p>

</div>
</div>
<a id="ade716899bdeb33ee65b644f28d7b7c1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade716899bdeb33ee65b644f28d7b7c1e">&#9670;&#160;</a></span>add_observation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gst::Clock::add_observation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a>&#160;</td>
          <td class="paramname"><em>slave_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a>&#160;</td>
          <td class="paramname"><em>master_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gdouble &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a>&amp;&#160;</td>
          <td class="paramname"><em>internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a>&amp;&#160;</td>
          <td class="paramname"><em>external</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a>&amp;&#160;</td>
          <td class="paramname"><em>rate_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a>&amp;&#160;</td>
          <td class="paramname"><em>rate_denom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a clock observation to the internal slaving algorithm the same as <a class="el" href="classGst_1_1Clock.html#aa76795d0374dc653b3b31d58652124be" title="The time master_time of the master clock and the time slave_time of the slave clock are added to the ...">add_observation()</a>, and return the result of the master clock estimation, without updating the internal calibration. </p>
<p>The caller can then take the results and call <a class="el" href="classGst_1_1Clock.html#a12463def9152956a420fcebe24939f4f" title="Adjusts the rate and time of clock. ">set_calibration()</a> with the values, or some modified version of them.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slave_time</td><td>A time on the slave. </td></tr>
    <tr><td class="paramname">master_time</td><td>A time on the master. </td></tr>
    <tr><td class="paramname">result</td><td>A pointer to hold the result. </td></tr>
    <tr><td class="paramname">internal</td><td>A location to store the internal time. </td></tr>
    <tr><td class="paramname">external</td><td>A location to store the external time. </td></tr>
    <tr><td class="paramname">rate_num</td><td>A location to store the rate numerator. </td></tr>
    <tr><td class="paramname">rate_denom</td><td>A location to store the rate denominator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9f72f5d84ce2735835a26cec51d21de4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f72f5d84ce2735835a26cec51d21de4">&#9670;&#160;</a></span>adjust_unlocked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a> Gst::Clock::adjust_unlocked </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a>&#160;</td>
          <td class="paramname"><em>internal_time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the given <em>internal_time</em> clock time to the external time, adjusting for the rate and reference time set with <a class="el" href="classGst_1_1Clock.html#a12463def9152956a420fcebe24939f4f" title="Adjusts the rate and time of clock. ">set_calibration()</a> and making sure that the returned time is increasing. </p>
<p>This function should be called with the clock's OBJECT_LOCK held and is mainly used by clock subclasses.</p>
<p>This function is the reverse of <a class="el" href="classGst_1_1Clock.html#a1557212b076a34b36502f87d0cd7c05c" title="Converts the given external_time clock time to the internal time of clock, using the rate and referen...">unadjust_unlocked()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">internal_time</td><td>A clock time. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The converted time of the clock. </dd></dl>

</div>
</div>
<a id="af9d74523eb34b8702a27740c48239b39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9d74523eb34b8702a27740c48239b39">&#9670;&#160;</a></span>adjust_with_calibration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a> Gst::Clock::adjust_with_calibration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a>&#160;</td>
          <td class="paramname"><em>internal_target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a>&#160;</td>
          <td class="paramname"><em>cinternal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a>&#160;</td>
          <td class="paramname"><em>cexternal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a>&#160;</td>
          <td class="paramname"><em>cnum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a>&#160;</td>
          <td class="paramname"><em>cdenom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the given <em>internal_target</em> clock time to the external time, using the passed calibration parameters. </p>
<p>This function performs the same calculation as <a class="el" href="classGst_1_1Clock.html#a9f72f5d84ce2735835a26cec51d21de4" title="Converts the given internal_time clock time to the external time, adjusting for the rate and referenc...">adjust_unlocked()</a> when called using the current calibration parameters, but doesn't ensure a monotonically increasing result as <a class="el" href="classGst_1_1Clock.html#a9f72f5d84ce2735835a26cec51d21de4" title="Converts the given internal_time clock time to the external time, adjusting for the rate and referenc...">adjust_unlocked()</a> does.</p>
<dl class="section note"><dt>Note</dt><dd>The <em>clock</em> parameter is unused and can be <code>nullptr</code></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">internal_target</td><td>A clock time. </td></tr>
    <tr><td class="paramname">cinternal</td><td>A reference internal time. </td></tr>
    <tr><td class="paramname">cexternal</td><td>A reference external time. </td></tr>
    <tr><td class="paramname">cnum</td><td>The numerator of the rate of the clock relative to its internal time. </td></tr>
    <tr><td class="paramname">cdenom</td><td>The denominator of the rate of the clock. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The converted time of the clock. </dd></dl>

</div>
</div>
<a id="add734cd91eba4da68639ebc4b80186ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add734cd91eba4da68639ebc4b80186ad">&#9670;&#160;</a></span>change_resolution_vfunc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a> Gst::Clock::change_resolution_vfunc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a>&#160;</td>
          <td class="paramname"><em>old_resolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a>&#160;</td>
          <td class="paramname"><em>new_resolution</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the resolution of the clock. </p>
<p>Not all values might be acceptable. The new resolution should be returned. </p>

</div>
</div>
<a id="ad82c3164cea026acbc4b7bc797502ad9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad82c3164cea026acbc4b7bc797502ad9">&#9670;&#160;</a></span>create_periodic_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::RefPtr&lt;<a class="el" href="classGst_1_1ClockID.html">Gst::ClockID</a>&gt; Gst::Clock::create_periodic_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a>&#160;</td>
          <td class="paramname"><em>start_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a>&#160;</td>
          <td class="paramname"><em>intervals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an ID from <em>clock</em> to trigger a periodic notification. </p>
<p>The periodic notifications will start at time <em>start_time</em> and will then be fired with the given <em>intervals</em>. <em>id</em> should be unreffed after usage.</p>
<p>Free-function: gst_clock_id_unref</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_time</td><td>The requested start time. </td></tr>
    <tr><td class="paramname">intervals</td><td>The requested interval. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classGst_1_1ClockID.html" title="A data type to hold the handle to an outstanding sync or async clock callback. ">Gst::ClockID</a> that can be used to request the time notification.</dd></dl>
<p>MT safe. </p>

</div>
</div>
<a id="ae5d5e8edfe6254d46c9ae6a7063fa3cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5d5e8edfe6254d46c9ae6a7063fa3cd">&#9670;&#160;</a></span>create_single_shot_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::RefPtr&lt;<a class="el" href="classGst_1_1ClockID.html">Gst::ClockID</a>&gt; Gst::Clock::create_single_shot_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a>&#160;</td>
          <td class="paramname"><em>time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a <a class="el" href="classGst_1_1ClockID.html" title="A data type to hold the handle to an outstanding sync or async clock callback. ">Gst::ClockID</a> from <em>clock</em> to trigger a single shot notification at the requested time. </p>
<p>The single shot id should be unreffed after usage.</p>
<p>Free-function: gst_clock_id_unref</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time</td><td>The requested time. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classGst_1_1ClockID.html" title="A data type to hold the handle to an outstanding sync or async clock callback. ">Gst::ClockID</a> that can be used to request the time notification.</dd></dl>
<p>MT safe. </p>

</div>
</div>
<a id="af91b25e9735944f9004a58d278d7fbc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af91b25e9735944f9004a58d278d7fbc9">&#9670;&#160;</a></span>get_calibration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gst::Clock::get_calibration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a>&amp;&#160;</td>
          <td class="paramname"><em>internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a>&amp;&#160;</td>
          <td class="paramname"><em>external</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a>&amp;&#160;</td>
          <td class="paramname"><em>rate_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a>&amp;&#160;</td>
          <td class="paramname"><em>rate_denom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the internal rate and reference time of <em>clock</em>. </p>
<p>See <a class="el" href="classGst_1_1Clock.html#a12463def9152956a420fcebe24939f4f" title="Adjusts the rate and time of clock. ">set_calibration()</a> for more information.</p>
<p><em>internal</em>, <em>external</em>, <em>rate_num</em>, and <em>rate_denom</em> can be left <code>nullptr</code> if the caller is not interested in the values.</p>
<p>MT safe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">internal</td><td>A location to store the internal time. </td></tr>
    <tr><td class="paramname">external</td><td>A location to store the external time. </td></tr>
    <tr><td class="paramname">rate_num</td><td>A location to store the rate numerator. </td></tr>
    <tr><td class="paramname">rate_denom</td><td>A location to store the rate denominator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6e08883b37732a51b00940a8bcd52a49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e08883b37732a51b00940a8bcd52a49">&#9670;&#160;</a></span>get_internal_time()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a> Gst::Clock::get_internal_time </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the current internal time of the given clock. </p>
<p>The time is returned unadjusted for the offset and the rate.</p>
<dl class="section return"><dt>Returns</dt><dd>The internal time of the clock. Or GST_CLOCK_TIME_NONE when given invalid input.</dd></dl>
<p>MT safe. </p>

</div>
</div>
<a id="af38e834ae74307bd2c3c399d7a2814ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af38e834ae74307bd2c3c399d7a2814ce">&#9670;&#160;</a></span>get_internal_time_vfunc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a> Gst::Clock::get_internal_time_vfunc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the internal unadjusted time of the clock. </p>

</div>
</div>
<a id="a305be78c4fdd5050463eb636feeb4c4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a305be78c4fdd5050463eb636feeb4c4c">&#9670;&#160;</a></span>get_master() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::RefPtr&lt;<a class="el" href="classGst_1_1Clock.html">Gst::Clock</a>&gt; Gst::Clock::get_master </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the master clock that <em>clock</em> is slaved to or <code>nullptr</code> when the clock is not slaved to any master clock. </p>
<dl class="section return"><dt>Returns</dt><dd>A master <a class="el" href="classGst_1_1Clock.html" title="Abstract class for global clocks GStreamer uses a global clock to synchronize the plugins in a pipeli...">Gst::Clock</a> or <code>nullptr</code> when this clock is not slaved to a master clock. Unref after usage.</dd></dl>
<p>MT safe. </p>

</div>
</div>
<a id="aabf6269b221411dd1be4d3a4a832ec90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabf6269b221411dd1be4d3a4a832ec90">&#9670;&#160;</a></span>get_master() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::RefPtr&lt;const <a class="el" href="classGst_1_1Clock.html">Gst::Clock</a>&gt; Gst::Clock::get_master </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the master clock that <em>clock</em> is slaved to or <code>nullptr</code> when the clock is not slaved to any master clock. </p>
<dl class="section return"><dt>Returns</dt><dd>A master <a class="el" href="classGst_1_1Clock.html" title="Abstract class for global clocks GStreamer uses a global clock to synchronize the plugins in a pipeli...">Gst::Clock</a> or <code>nullptr</code> when this clock is not slaved to a master clock. Unref after usage.</dd></dl>
<p>MT safe. </p>

</div>
</div>
<a id="a35746a3b6a929aa7b62b1c4986a23a40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35746a3b6a929aa7b62b1c4986a23a40">&#9670;&#160;</a></span>get_resolution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a> Gst::Clock::get_resolution </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the accuracy of the clock. </p>
<p>The accuracy of the clock is the granularity of the values returned by <a class="el" href="classGst_1_1Clock.html#af263ed436ab5f105f1e6cc71243ed65e" title="Gets the current time of the given clock. ">get_time()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>The resolution of the clock in units of <a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda" title="A data type to hold a time, measured in nanoseconds. ">Gst::ClockTime</a>.</dd></dl>
<p>MT safe. </p>

</div>
</div>
<a id="a510a92b097c131fdbf516ce736dc14e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a510a92b097c131fdbf516ce736dc14e7">&#9670;&#160;</a></span>get_resolution_vfunc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a> Gst::Clock::get_resolution_vfunc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the resolution of the clock. </p>

</div>
</div>
<a id="af263ed436ab5f105f1e6cc71243ed65e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af263ed436ab5f105f1e6cc71243ed65e">&#9670;&#160;</a></span>get_time()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a> Gst::Clock::get_time </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the current time of the given clock. </p>
<p>The time is always monotonically increasing and adjusted according to the current offset and rate.</p>
<dl class="section return"><dt>Returns</dt><dd>The time of the clock. Or GST_CLOCK_TIME_NONE when given invalid input.</dd></dl>
<p>MT safe. </p>

</div>
</div>
<a id="ab84fc422b0572b71504a4646384b2b84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab84fc422b0572b71504a4646384b2b84">&#9670;&#160;</a></span>get_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static GType Gst::Clock::get_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the GType for this class, for use with the underlying GObject type system. </p>

</div>
</div>
<a id="aa0459a0384c1e5432b82764c7810f05d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0459a0384c1e5432b82764c7810f05d">&#9670;&#160;</a></span>gobj() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GstClock* Gst::Clock::gobj </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides access to the underlying C GObject. </p>

</div>
</div>
<a id="a2563d4c0429a9ed65e3712af76730f26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2563d4c0429a9ed65e3712af76730f26">&#9670;&#160;</a></span>gobj() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const GstClock* Gst::Clock::gobj </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides access to the underlying C GObject. </p>

</div>
</div>
<a id="ae7273dacc028b733d43ebc92b4f2e6bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7273dacc028b733d43ebc92b4f2e6bb">&#9670;&#160;</a></span>gobj_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GstClock* Gst::Clock::gobj_copy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides access to the underlying C instance. The caller is responsible for unrefing it. Use when directly setting fields in structs. </p>

</div>
</div>
<a id="a56dd59f66db560843fb1bbcdf4177cf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56dd59f66db560843fb1bbcdf4177cf3">&#9670;&#160;</a></span>is_synced()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gst::Clock::is_synced </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the clock is currently synced. </p>
<p>This returns if GST_CLOCK_FLAG_NEEDS_STARTUP_SYNC is not set on the clock.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the clock is currently synced. </dd></dl>

</div>
</div>
<a id="a0149011f8e53ffdf3df0a6d0f2dc479c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0149011f8e53ffdf3df0a6d0f2dc479c">&#9670;&#160;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGst_1_1Clock.html">Clock</a>&amp; Gst::Clock::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGst_1_1Clock.html">Clock</a>&amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acef159f9f299d14b275acc5d38ee52f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acef159f9f299d14b275acc5d38ee52f7">&#9670;&#160;</a></span>periodic_id_reinit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gst::Clock::periodic_id_reinit </td>
          <td>(</td>
          <td class="paramtype">const Glib::RefPtr&lt; <a class="el" href="classGst_1_1ClockID.html">Gst::ClockID</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a>&#160;</td>
          <td class="paramname"><em>start_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a>&#160;</td>
          <td class="paramname"><em>interval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reinitializes the provided periodic <em>id</em> to the provided start time and interval. </p>
<p>Does not modify the reference count.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>A <a class="el" href="classGst_1_1ClockID.html" title="A data type to hold the handle to an outstanding sync or async clock callback. ">Gst::ClockID</a>. </td></tr>
    <tr><td class="paramname">start_time</td><td>The requested start time. </td></tr>
    <tr><td class="paramname">interval</td><td>The requested interval. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the GstClockID could be reinitialized to the provided <em>time</em>, else <code>false</code>. </dd></dl>

</div>
</div>
<a id="a3384c43f37681ab6d5cb4a859f1665cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3384c43f37681ab6d5cb4a859f1665cc">&#9670;&#160;</a></span>property_timeout() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::PropertyProxy&lt; guint64 &gt; Gst::Clock::property_timeout </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get/set timeout can be achieved through 'timeout' property, so wrapping gst_clock_{get|set|_timeout is unnecessary. </p>
<p>The amount of time, in nanoseconds, to sample master and slave clocks.</p>
<dl class="section return"><dt>Returns</dt><dd>A PropertyProxy that allows you to get or set the value of the property, or receive notification when the value of the property changes. </dd></dl>

</div>
</div>
<a id="aa064dd76f12f488fea80e2f3350b2cf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa064dd76f12f488fea80e2f3350b2cf3">&#9670;&#160;</a></span>property_timeout() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::PropertyProxy_ReadOnly&lt; guint64 &gt; Gst::Clock::property_timeout </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The amount of time, in nanoseconds, to sample master and slave clocks. </p>
<dl class="section return"><dt>Returns</dt><dd>A PropertyProxy_ReadOnly that allows you to get the value of the property, or receive notification when the value of the property changes. </dd></dl>

</div>
</div>
<a id="a03273877de11001166d9594fec12b423"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03273877de11001166d9594fec12b423">&#9670;&#160;</a></span>property_window_size() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::PropertyProxy&lt; int &gt; Gst::Clock::property_window_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The size of the window used to calculate rate and offset. </p>
<dl class="section return"><dt>Returns</dt><dd>A PropertyProxy that allows you to get or set the value of the property, or receive notification when the value of the property changes. </dd></dl>

</div>
</div>
<a id="a959ee0d9e7d79ba793e860a57077c17d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a959ee0d9e7d79ba793e860a57077c17d">&#9670;&#160;</a></span>property_window_size() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::PropertyProxy_ReadOnly&lt; int &gt; Gst::Clock::property_window_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The size of the window used to calculate rate and offset. </p>
<dl class="section return"><dt>Returns</dt><dd>A PropertyProxy_ReadOnly that allows you to get the value of the property, or receive notification when the value of the property changes. </dd></dl>

</div>
</div>
<a id="ad405ca953c118dc54146d3d97a0d066f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad405ca953c118dc54146d3d97a0d066f">&#9670;&#160;</a></span>property_window_threshold() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::PropertyProxy&lt; int &gt; Gst::Clock::property_window_threshold </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The threshold to start calculating rate and offset. </p>
<dl class="section return"><dt>Returns</dt><dd>A PropertyProxy that allows you to get or set the value of the property, or receive notification when the value of the property changes. </dd></dl>

</div>
</div>
<a id="aae2c7caf6770fea8e4d82f3ca1a54efb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae2c7caf6770fea8e4d82f3ca1a54efb">&#9670;&#160;</a></span>property_window_threshold() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::PropertyProxy_ReadOnly&lt; int &gt; Gst::Clock::property_window_threshold </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The threshold to start calculating rate and offset. </p>
<dl class="section return"><dt>Returns</dt><dd>A PropertyProxy_ReadOnly that allows you to get the value of the property, or receive notification when the value of the property changes. </dd></dl>

</div>
</div>
<a id="a12463def9152956a420fcebe24939f4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12463def9152956a420fcebe24939f4f">&#9670;&#160;</a></span>set_calibration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gst::Clock::set_calibration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a>&#160;</td>
          <td class="paramname"><em>internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a>&#160;</td>
          <td class="paramname"><em>external</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a>&#160;</td>
          <td class="paramname"><em>rate_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a>&#160;</td>
          <td class="paramname"><em>rate_denom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adjusts the rate and time of <em>clock</em>. </p>
<p>A rate of 1/1 is the normal speed of the clock. Values bigger than 1/1 make the clock go faster.</p>
<p><em>internal</em> and <em>external</em> are calibration parameters that arrange that <a class="el" href="classGst_1_1Clock.html#af263ed436ab5f105f1e6cc71243ed65e" title="Gets the current time of the given clock. ">get_time()</a> should have been <em>external</em> at internal time <em>internal</em>. This internal time should not be in the future; that is, it should be less than the value of <a class="el" href="classGst_1_1Clock.html#a6e08883b37732a51b00940a8bcd52a49" title="Gets the current internal time of the given clock. ">get_internal_time()</a> when this function is called.</p>
<p>Subsequent calls to <a class="el" href="classGst_1_1Clock.html#af263ed436ab5f105f1e6cc71243ed65e" title="Gets the current time of the given clock. ">get_time()</a> will return clock times computed as follows:</p>
<p>time = (internal_time - internal) * rate_num / rate_denom + external</p>
<p>This formula is implemented in <a class="el" href="classGst_1_1Clock.html#a9f72f5d84ce2735835a26cec51d21de4" title="Converts the given internal_time clock time to the external time, adjusting for the rate and referenc...">adjust_unlocked()</a>. Of course, it tries to do the integer arithmetic as precisely as possible.</p>
<p>Note that <a class="el" href="classGst_1_1Clock.html#af263ed436ab5f105f1e6cc71243ed65e" title="Gets the current time of the given clock. ">get_time()</a> always returns increasing values so when you move the clock backwards, <a class="el" href="classGst_1_1Clock.html#af263ed436ab5f105f1e6cc71243ed65e" title="Gets the current time of the given clock. ">get_time()</a> will report the previous value until the clock catches up.</p>
<p>MT safe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">internal</td><td>A reference internal time. </td></tr>
    <tr><td class="paramname">external</td><td>A reference external time. </td></tr>
    <tr><td class="paramname">rate_num</td><td>The numerator of the rate of the clock relative to its internal time. </td></tr>
    <tr><td class="paramname">rate_denom</td><td>The denominator of the rate of the clock. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab85ebe6e289302d83738ccd55bbfe4b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab85ebe6e289302d83738ccd55bbfe4b6">&#9670;&#160;</a></span>set_master()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gst::Clock::set_master </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGst_1_1Clock.html">Clock</a>&amp;&#160;</td>
          <td class="paramname"><em>master_clock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set <em>master_clock</em> as the master clock for <em>clock</em>. </p>
<p><em>clock</em> will be automatically calibrated so that <a class="el" href="classGst_1_1Clock.html#af263ed436ab5f105f1e6cc71243ed65e" title="Gets the current time of the given clock. ">get_time()</a> reports the same time as the master clock.</p>
<p>A clock provider that slaves its clock to a master can get the current calibration values with <a class="el" href="classGst_1_1Clock.html#af91b25e9735944f9004a58d278d7fbc9" title="Gets the internal rate and reference time of clock. ">get_calibration()</a>.</p>
<p><em>master_clock</em> can be <code>nullptr</code> in which case <em>clock</em> will not be slaved anymore. It will however keep reporting its time adjusted with the last configured rate and time offsets.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">master_clock</td><td>A master <a class="el" href="classGst_1_1Clock.html" title="Abstract class for global clocks GStreamer uses a global clock to synchronize the plugins in a pipeli...">Gst::Clock</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the clock is capable of being slaved to a master clock. Trying to set a master on a clock without the <a class="el" href="namespaceGst.html#gae4cd01977bbec7f009fb9725d8cfa080ae305a77c17a6fc0d404e4c8fcbea27c3" title="Clock can be slaved to a master clock. ">Gst::CLOCK_FLAG_CAN_SET_MASTER</a> flag will make this function return <code>false</code>.</dd></dl>
<p>MT safe. </p>

</div>
</div>
<a id="a2fb3ee60a15a29546a9ed805b15944bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fb3ee60a15a29546a9ed805b15944bb">&#9670;&#160;</a></span>set_resolution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a> Gst::Clock::set_resolution </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a>&#160;</td>
          <td class="paramname"><em>resolution</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the accuracy of the clock. </p>
<p>Some clocks have the possibility to operate with different accuracy at the expense of more resource usage. There is normally no need to change the default resolution of a clock. The resolution of a clock can only be changed if the clock has the <a class="el" href="namespaceGst.html#gae4cd01977bbec7f009fb9725d8cfa080ae494b270a816065047a03827f41f8449" title="Clock&#39;s resolution can be changed. ">Gst::CLOCK_FLAG_CAN_SET_RESOLUTION</a> flag set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resolution</td><td>The resolution to set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new resolution of the clock. </dd></dl>

</div>
</div>
<a id="a585e591201ecd7f11f7a16ab5a549af8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a585e591201ecd7f11f7a16ab5a549af8">&#9670;&#160;</a></span>set_synced()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gst::Clock::set_synced </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>synced</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets <em>clock</em> to synced and emits the GstClock::synced signal, and wakes up any thread waiting in <a class="el" href="classGst_1_1Clock.html#ab25f2d5423c487e02248733b819b9cad" title="Waits until clock is synced for reporting the current time. ">wait_for_sync()</a>. </p>
<p>This function must only be called if GST_CLOCK_FLAG_NEEDS_STARTUP_SYNC is set on the clock, and is intended to be called by subclasses only.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">synced</td><td>If the clock is synced. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af611b1720354f8c3c553e2d819cea002"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af611b1720354f8c3c553e2d819cea002">&#9670;&#160;</a></span>signal_synced()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::SignalProxy&lt; void,bool &gt; Gst::Clock::signal_synced </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section user"><dt>Slot Prototype:</dt><dd><code>void on_my_synced(bool synced)</code></dd></dl>
<p>Signaled on clocks with GST_CLOCK_FLAG_NEEDS_STARTUP_SYNC set once the clock is synchronized, or when it completely lost synchronization. This signal will not be emitted on clocks without the flag.</p>
<p>This signal will be emitted from an arbitrary thread, most likely not the application's main thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">synced</td><td>If the clock is synced now. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8e62295c4f51fd262caba789c4638cb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e62295c4f51fd262caba789c4638cb3">&#9670;&#160;</a></span>single_shot_id_reinit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gst::Clock::single_shot_id_reinit </td>
          <td>(</td>
          <td class="paramtype">const Glib::RefPtr&lt; <a class="el" href="classGst_1_1ClockID.html">Gst::ClockID</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a>&#160;</td>
          <td class="paramname"><em>time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reinitializes the provided single shot <em>id</em> to the provided time. </p>
<p>Does not modify the reference count.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>A <a class="el" href="classGst_1_1ClockID.html" title="A data type to hold the handle to an outstanding sync or async clock callback. ">Gst::ClockID</a>. </td></tr>
    <tr><td class="paramname">time</td><td>The requested time. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the GstClockID could be reinitialized to the provided <em>time</em>, else <code>false</code>. </dd></dl>

</div>
</div>
<a id="a1557212b076a34b36502f87d0cd7c05c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1557212b076a34b36502f87d0cd7c05c">&#9670;&#160;</a></span>unadjust_unlocked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a> Gst::Clock::unadjust_unlocked </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a>&#160;</td>
          <td class="paramname"><em>external_time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the given <em>external_time</em> clock time to the internal time of <em>clock</em>, using the rate and reference time set with <a class="el" href="classGst_1_1Clock.html#a12463def9152956a420fcebe24939f4f" title="Adjusts the rate and time of clock. ">set_calibration()</a>. </p>
<p>This function should be called with the clock's OBJECT_LOCK held and is mainly used by clock subclasses.</p>
<p>This function is the reverse of <a class="el" href="classGst_1_1Clock.html#a9f72f5d84ce2735835a26cec51d21de4" title="Converts the given internal_time clock time to the external time, adjusting for the rate and referenc...">adjust_unlocked()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">external_time</td><td>An external clock time. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The internal time of the clock corresponding to <em>external_time</em>. </dd></dl>

</div>
</div>
<a id="a57e31b2b74b01255ee4860e634d9180c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57e31b2b74b01255ee4860e634d9180c">&#9670;&#160;</a></span>unadjust_with_calibration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a> Gst::Clock::unadjust_with_calibration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a>&#160;</td>
          <td class="paramname"><em>external_target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a>&#160;</td>
          <td class="paramname"><em>cinternal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a>&#160;</td>
          <td class="paramname"><em>cexternal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a>&#160;</td>
          <td class="paramname"><em>cnum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a>&#160;</td>
          <td class="paramname"><em>cdenom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the given <em>external_target</em> clock time to the internal time, using the passed calibration parameters. </p>
<p>This function performs the same calculation as <a class="el" href="classGst_1_1Clock.html#a1557212b076a34b36502f87d0cd7c05c" title="Converts the given external_time clock time to the internal time of clock, using the rate and referen...">unadjust_unlocked()</a> when called using the current calibration parameters.</p>
<dl class="section note"><dt>Note</dt><dd>The <em>clock</em> parameter is unused and can be <code>nullptr</code></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">external_target</td><td>A clock time. </td></tr>
    <tr><td class="paramname">cinternal</td><td>A reference internal time. </td></tr>
    <tr><td class="paramname">cexternal</td><td>A reference external time. </td></tr>
    <tr><td class="paramname">cnum</td><td>The numerator of the rate of the clock relative to its internal time. </td></tr>
    <tr><td class="paramname">cdenom</td><td>The denominator of the rate of the clock. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The converted time of the clock. </dd></dl>

</div>
</div>
<a id="abc41eb372e0f7b1ad9071f53ba668eeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc41eb372e0f7b1ad9071f53ba668eeb">&#9670;&#160;</a></span>unschedule_vfunc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Gst::Clock::unschedule_vfunc </td>
          <td>(</td>
          <td class="paramtype">const Glib::RefPtr&lt; <a class="el" href="classGst_1_1ClockID.html">Gst::ClockID</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unblock a blocking or async wait operation. </p>

</div>
</div>
<a id="ae5f4d706cab453f51c822f2abf4bde12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5f4d706cab453f51c822f2abf4bde12">&#9670;&#160;</a></span>wait_async_vfunc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__gstreamermmEnums.html#gaa501f23d690de389e755e652093d9392">ClockReturn</a> Gst::Clock::wait_async_vfunc </td>
          <td>(</td>
          <td class="paramtype">const Glib::RefPtr&lt; <a class="el" href="classGst_1_1ClockID.html">Gst::ClockID</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform an asynchronous wait for the given <a class="el" href="classGst_1_1ClockID.html" title="A data type to hold the handle to an outstanding sync or async clock callback. ">Gst::ClockID</a>. </p>

</div>
</div>
<a id="ab25f2d5423c487e02248733b819b9cad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab25f2d5423c487e02248733b819b9cad">&#9670;&#160;</a></span>wait_for_sync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gst::Clock::wait_for_sync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a>&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waits until <em>clock</em> is synced for reporting the current time. </p>
<p>If <em>timeout</em> is <a class="el" href="namespaceGst.html#a07ca62fa6d891070ab6d46c45cd388f1" title="A constant to define an undefined clock time. ">Gst::CLOCK_TIME_NONE</a> it will wait forever, otherwise it will time out after <em>timeout</em> nanoseconds.</p>
<p>For asynchronous waiting, the GstClock::synced signal can be used.</p>
<p>This returns immediately with <code>true</code> if GST_CLOCK_FLAG_NEEDS_STARTUP_SYNC is not set on the clock, or if the clock is already synced.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>Timeout for waiting or <a class="el" href="namespaceGst.html#a07ca62fa6d891070ab6d46c45cd388f1" title="A constant to define an undefined clock time. ">Gst::CLOCK_TIME_NONE</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if waiting was successful, or <code>false</code> on timeout. </dd></dl>

</div>
</div>
<a id="add60e95e1f185910dfacfa17fc5a63a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add60e95e1f185910dfacfa17fc5a63a8">&#9670;&#160;</a></span>wait_vfunc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__gstreamermmEnums.html#gaa501f23d690de389e755e652093d9392">ClockReturn</a> Gst::Clock::wait_vfunc </td>
          <td>(</td>
          <td class="paramtype">const Glib::RefPtr&lt; <a class="el" href="classGst_1_1ClockID.html">Gst::ClockID</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceGst.html#a1bd878eb666682156ef268a6ff0ad16c">Gst::ClockTimeDiff</a>&amp;&#160;</td>
          <td class="paramname"><em>jitter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a blocking wait for the given <a class="el" href="classGst_1_1ClockID.html" title="A data type to hold the handle to an outstanding sync or async clock callback. ">Gst::ClockID</a>. </p>
<p>Deprecated, implement wait_jitter_vfunc() instead. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="aa055df9465a22ca8144c637617a3fea9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa055df9465a22ca8144c637617a3fea9">&#9670;&#160;</a></span>wrap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Glib::RefPtr&lt; <a class="el" href="classGst_1_1Clock.html">Gst::Clock</a> &gt; wrap </td>
          <td>(</td>
          <td class="paramtype">GstClock *&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>take_copy</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A <a class="el" href="namespaceGlib.html#a43fcab2a44083e8b7b6a1c8193acae2b">Glib::wrap()</a> method for this object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">object</td><td>The C instance. </td></tr>
    <tr><td class="paramname">take_copy</td><td>False if the result should take ownership of the C instance. True if it should take a new copy or ref. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A C++ instance that wraps this C instance. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Oct 21 2017 12:59:00 for gstreamermm by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
