<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>gstreamermm: Gst::Element Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">gstreamermm
   &#160;<span id="projectnumber">1.10.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceGst.html">Gst</a></li><li class="navelem"><a class="el" href="classGst_1_1Element.html">Element</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classGst_1_1Element-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Gst::Element Class Reference<div class="ingroups"><a class="el" href="group__GstBaseClasses.html">gstreamermm Base Classes</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Abstract base class for all pipeline elements.  
 <a href="classGst_1_1Element.html#details">More...</a></p>

<p><code>#include &lt;gstreamermm/element.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Gst::Element:</div>
<div class="dyncontent">
<div class="center"><img src="classGst_1_1Element__inherit__graph.png" border="0" usemap="#Gst_1_1Element_inherit__map" alt="Inheritance graph"/></div>
<map name="Gst_1_1Element_inherit__map" id="Gst_1_1Element_inherit__map">
<area shape="rect" id="node3" href="classGst_1_1BaseSink.html" title="The base class for sink elements. " alt="" coords="178,155,289,181"/>
<area shape="rect" id="node7" href="classGst_1_1BaseSrc.html" title="A base class for getrange based source elements. " alt="" coords="313,155,418,181"/>
<area shape="rect" id="node12" href="classGst_1_1BaseTransform.html" title="A base class for simple transform filters. " alt="" coords="443,155,589,181"/>
<area shape="rect" id="node14" href="classGst_1_1Bin.html" title="Base class and element that can contain other elements. " alt="" coords="613,155,685,181"/>
<area shape="rect" id="node2" href="classGst_1_1Object.html" title="A base class for the GStreamer object hierarchy. " alt="" coords="393,5,487,32"/>
<area shape="rect" id="node4" href="classGst_1_1AudioBaseSink.html" title="The base class for audio sinks. " alt="" coords="5,229,152,256"/>
<area shape="rect" id="node6" href="classGst_1_1VideoSink.html" title="A base class for video sinks. " alt="" coords="176,229,291,256"/>
<area shape="rect" id="node5" href="classGst_1_1AudioSink.html" title="A simple base class for audio sinks. " alt="" coords="21,304,136,331"/>
<area shape="rect" id="node8" href="classGst_1_1PushSrc.html" title="A base class for push based source elements. " alt="" coords="315,229,419,256"/>
<area shape="rect" id="node9" href="classGst_1_1AudioBaseSrc.html" title="The base class for audio sources. " alt="" coords="228,304,369,331"/>
<area shape="rect" id="node11" href="classGst_1_1AudioCdSrc.html" title="A base class for CD digital audio (CDDA) sources, which handles things like seeking, querying, discid calculation, tags, and buffer timestamping. " alt="" coords="394,304,521,331"/>
<area shape="rect" id="node10" href="classGst_1_1AudioSrc.html" title="A simple base class for audio sources. " alt="" coords="244,379,353,405"/>
<area shape="rect" id="node13" href="classGst_1_1AudioFilter.html" title="A base class for simple audio filters. " alt="" coords="455,229,574,256"/>
<area shape="rect" id="node15" href="classGst_1_1Pipeline.html" title="A top&#45;level bin with clocking and bus management functionality. " alt="" coords="599,229,700,256"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a68bf7407277bbe872ad6900643f581e4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Element.html#a68bf7407277bbe872ad6900643f581e4">Element</a> (<a class="el" href="classGst_1_1Element.html">Element</a>&amp;&amp; src) noexcept</td></tr>
<tr class="separator:a68bf7407277bbe872ad6900643f581e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f6d05c3719a775b527186f1b0dad35d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGst_1_1Element.html">Element</a>&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Element.html#a4f6d05c3719a775b527186f1b0dad35d">operator=</a> (<a class="el" href="classGst_1_1Element.html">Element</a>&amp;&amp; src) noexcept</td></tr>
<tr class="separator:a4f6d05c3719a775b527186f1b0dad35d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54a2f9a1318f4dfeaaecfb590601011c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Element.html#a54a2f9a1318f4dfeaaecfb590601011c">~Element</a> () noexcept override</td></tr>
<tr class="separator:a54a2f9a1318f4dfeaaecfb590601011c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7385513759359ebfb349b824ab463dbc"><td class="memItemLeft" align="right" valign="top">GstElement*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Element.html#a7385513759359ebfb349b824ab463dbc">gobj</a> ()</td></tr>
<tr class="memdesc:a7385513759359ebfb349b824ab463dbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the underlying C GObject.  <a href="#a7385513759359ebfb349b824ab463dbc">More...</a><br /></td></tr>
<tr class="separator:a7385513759359ebfb349b824ab463dbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fa5fccfc067ed5d651f13e20ca052f2"><td class="memItemLeft" align="right" valign="top">const GstElement*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Element.html#a7fa5fccfc067ed5d651f13e20ca052f2">gobj</a> () const</td></tr>
<tr class="memdesc:a7fa5fccfc067ed5d651f13e20ca052f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the underlying C GObject.  <a href="#a7fa5fccfc067ed5d651f13e20ca052f2">More...</a><br /></td></tr>
<tr class="separator:a7fa5fccfc067ed5d651f13e20ca052f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf406873b4b57582deff89ed621fb297"><td class="memItemLeft" align="right" valign="top">GstElement*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Element.html#aaf406873b4b57582deff89ed621fb297">gobj_copy</a> ()</td></tr>
<tr class="memdesc:aaf406873b4b57582deff89ed621fb297"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the underlying C instance. The caller is responsible for unrefing it. Use when directly setting fields in structs.  <a href="#aaf406873b4b57582deff89ed621fb297">More...</a><br /></td></tr>
<tr class="separator:aaf406873b4b57582deff89ed621fb297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab41115df14a718d340380c2d719a6ae4"><td class="memItemLeft" align="right" valign="top">Glib::RefPtr&lt; <a class="el" href="classGst_1_1Element.html">Gst::Element</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Element.html#ab41115df14a718d340380c2d719a6ae4">link</a> (const Glib::RefPtr&lt; <a class="el" href="classGst_1_1Element.html">Gst::Element</a> &gt;&amp; dest)</td></tr>
<tr class="memdesc:ab41115df14a718d340380c2d719a6ae4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Links this source element to the <em>dest</em> element.  <a href="#ab41115df14a718d340380c2d719a6ae4">More...</a><br /></td></tr>
<tr class="separator:ab41115df14a718d340380c2d719a6ae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f20a79f8c4f5e8503efe4a2a81f6dcb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Element.html#a6f20a79f8c4f5e8503efe4a2a81f6dcb">add_pad</a> (const Glib::RefPtr&lt; <a class="el" href="classGst_1_1Pad.html">Gst::Pad</a> &gt;&amp; pad)</td></tr>
<tr class="memdesc:a6f20a79f8c4f5e8503efe4a2a81f6dcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a pad (link point) to <em>element</em>.  <a href="#a6f20a79f8c4f5e8503efe4a2a81f6dcb">More...</a><br /></td></tr>
<tr class="separator:a6f20a79f8c4f5e8503efe4a2a81f6dcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb7cdeb640b7bee61540db8f39baa13d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Element.html#abb7cdeb640b7bee61540db8f39baa13d">create_all_pads</a> ()</td></tr>
<tr class="memdesc:abb7cdeb640b7bee61540db8f39baa13d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pad for each pad template that is always available.  <a href="#abb7cdeb640b7bee61540db8f39baa13d">More...</a><br /></td></tr>
<tr class="separator:abb7cdeb640b7bee61540db8f39baa13d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd2707d6644b4713012e474050bbd9eb"><td class="memItemLeft" align="right" valign="top">Glib::RefPtr&lt; <a class="el" href="classGst_1_1Pad.html">Gst::Pad</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Element.html#abd2707d6644b4713012e474050bbd9eb">create_compatible_pad</a> (const Glib::RefPtr&lt; const <a class="el" href="classGst_1_1Pad.html">Gst::Pad</a> &gt;&amp; pad, const Glib::RefPtr&lt; const <a class="el" href="classGst_1_1Caps.html">Gst::Caps</a> &gt;&amp; caps)</td></tr>
<tr class="memdesc:abd2707d6644b4713012e474050bbd9eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Looks for an unlinked pad to which the given pad can link.  <a href="#abd2707d6644b4713012e474050bbd9eb">More...</a><br /></td></tr>
<tr class="separator:abd2707d6644b4713012e474050bbd9eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e9331096e5f7f04c656ba8e7e09b77d"><td class="memItemLeft" align="right" valign="top">Glib::RefPtr&lt; <a class="el" href="classGst_1_1PadTemplate.html">Gst::PadTemplate</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Element.html#a1e9331096e5f7f04c656ba8e7e09b77d">get_compatible_pad_template</a> (const Glib::RefPtr&lt; const <a class="el" href="classGst_1_1PadTemplate.html">Gst::PadTemplate</a> &gt;&amp; compattempl)</td></tr>
<tr class="memdesc:a1e9331096e5f7f04c656ba8e7e09b77d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a pad template from <em>element</em> that is compatible with <em>compattempl</em>.  <a href="#a1e9331096e5f7f04c656ba8e7e09b77d">More...</a><br /></td></tr>
<tr class="separator:a1e9331096e5f7f04c656ba8e7e09b77d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84168677c3acfe326e22e78fa9c7d09b"><td class="memItemLeft" align="right" valign="top">Glib::RefPtr&lt; const <a class="el" href="classGst_1_1PadTemplate.html">Gst::PadTemplate</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Element.html#a84168677c3acfe326e22e78fa9c7d09b">get_compatible_pad_template</a> (const Glib::RefPtr&lt; const <a class="el" href="classGst_1_1PadTemplate.html">Gst::PadTemplate</a> &gt;&amp; compattempl) const</td></tr>
<tr class="memdesc:a84168677c3acfe326e22e78fa9c7d09b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a pad template from <em>element</em> that is compatible with <em>compattempl</em>.  <a href="#a84168677c3acfe326e22e78fa9c7d09b">More...</a><br /></td></tr>
<tr class="separator:a84168677c3acfe326e22e78fa9c7d09b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea8e7821ecf7acdd24bb08b0e638caa7"><td class="memItemLeft" align="right" valign="top">Glib::RefPtr&lt; <a class="el" href="classGst_1_1Pad.html">Gst::Pad</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Element.html#aea8e7821ecf7acdd24bb08b0e638caa7">get_request_pad</a> (const Glib::ustring&amp; name)</td></tr>
<tr class="memdesc:aea8e7821ecf7acdd24bb08b0e638caa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a pad from the element by name (e.g. "src_\\%d").  <a href="#aea8e7821ecf7acdd24bb08b0e638caa7">More...</a><br /></td></tr>
<tr class="separator:aea8e7821ecf7acdd24bb08b0e638caa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad082533664f013db0c3e629a00142464"><td class="memItemLeft" align="right" valign="top">Glib::RefPtr&lt; <a class="el" href="classGst_1_1Pad.html">Gst::Pad</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Element.html#ad082533664f013db0c3e629a00142464">request_pad</a> (const Glib::RefPtr&lt; <a class="el" href="classGst_1_1PadTemplate.html">Gst::PadTemplate</a> &gt;&amp; templ, const Glib::ustring&amp; name, const Glib::RefPtr&lt; const <a class="el" href="classGst_1_1Caps.html">Gst::Caps</a> &gt;&amp; caps)</td></tr>
<tr class="memdesc:ad082533664f013db0c3e629a00142464"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a request pad from the element according to the provided template.  <a href="#ad082533664f013db0c3e629a00142464">More...</a><br /></td></tr>
<tr class="separator:ad082533664f013db0c3e629a00142464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90acea759133eb20d42bc5ace1c2eff3"><td class="memItemLeft" align="right" valign="top">Glib::RefPtr&lt; <a class="el" href="classGst_1_1Pad.html">Gst::Pad</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Element.html#a90acea759133eb20d42bc5ace1c2eff3">request_pad</a> (const Glib::RefPtr&lt; <a class="el" href="classGst_1_1PadTemplate.html">Gst::PadTemplate</a> &gt;&amp; templ, const Glib::ustring&amp; name)</td></tr>
<tr class="memdesc:a90acea759133eb20d42bc5ace1c2eff3"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classGst_1_1Element.html#ad082533664f013db0c3e629a00142464" title="Retrieves a request pad from the element according to the provided template. ">request_pad()</a> convenience overload.  <a href="#a90acea759133eb20d42bc5ace1c2eff3">More...</a><br /></td></tr>
<tr class="separator:a90acea759133eb20d42bc5ace1c2eff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae726bdf0cfd604bb612ab8aca76e8833"><td class="memItemLeft" align="right" valign="top">Glib::RefPtr&lt; <a class="el" href="classGst_1_1Pad.html">Gst::Pad</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Element.html#ae726bdf0cfd604bb612ab8aca76e8833">request_pad</a> (const Glib::RefPtr&lt; <a class="el" href="classGst_1_1PadTemplate.html">Gst::PadTemplate</a> &gt;&amp; templ, const Glib::RefPtr&lt; const <a class="el" href="classGst_1_1Caps.html">Gst::Caps</a> &gt;&amp; caps)</td></tr>
<tr class="memdesc:ae726bdf0cfd604bb612ab8aca76e8833"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classGst_1_1Element.html#ad082533664f013db0c3e629a00142464" title="Retrieves a request pad from the element according to the provided template. ">request_pad()</a> convenience overload.  <a href="#ae726bdf0cfd604bb612ab8aca76e8833">More...</a><br /></td></tr>
<tr class="separator:ae726bdf0cfd604bb612ab8aca76e8833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae53c76cd339a8d3b5a8bc676a577b578"><td class="memItemLeft" align="right" valign="top">Glib::RefPtr&lt; <a class="el" href="classGst_1_1Pad.html">Gst::Pad</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Element.html#ae53c76cd339a8d3b5a8bc676a577b578">request_pad</a> (const Glib::RefPtr&lt; <a class="el" href="classGst_1_1PadTemplate.html">Gst::PadTemplate</a> &gt;&amp; templ)</td></tr>
<tr class="memdesc:ae53c76cd339a8d3b5a8bc676a577b578"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classGst_1_1Element.html#ad082533664f013db0c3e629a00142464" title="Retrieves a request pad from the element according to the provided template. ">request_pad()</a> convenience overload.  <a href="#ae53c76cd339a8d3b5a8bc676a577b578">More...</a><br /></td></tr>
<tr class="separator:ae53c76cd339a8d3b5a8bc676a577b578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71121475e7d509dfc1afb289ecb42dbc"><td class="memItemLeft" align="right" valign="top">Glib::RefPtr&lt; <a class="el" href="classGst_1_1Pad.html">Gst::Pad</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Element.html#a71121475e7d509dfc1afb289ecb42dbc">get_static_pad</a> (const Glib::ustring&amp; name)</td></tr>
<tr class="memdesc:a71121475e7d509dfc1afb289ecb42dbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a pad from <em>element</em> by name.  <a href="#a71121475e7d509dfc1afb289ecb42dbc">More...</a><br /></td></tr>
<tr class="separator:a71121475e7d509dfc1afb289ecb42dbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc250ffcde9c807734449702d2ab4c56"><td class="memItemLeft" align="right" valign="top">Glib::RefPtr&lt; const <a class="el" href="classGst_1_1Pad.html">Gst::Pad</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Element.html#afc250ffcde9c807734449702d2ab4c56">get_static_pad</a> (const Glib::ustring&amp; name) const</td></tr>
<tr class="memdesc:afc250ffcde9c807734449702d2ab4c56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a pad from <em>element</em> by name.  <a href="#afc250ffcde9c807734449702d2ab4c56">More...</a><br /></td></tr>
<tr class="separator:afc250ffcde9c807734449702d2ab4c56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2d2718fe5d4f400d91002edf683e8b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Element.html#ab2d2718fe5d4f400d91002edf683e8b2">no_more_pads</a> ()</td></tr>
<tr class="memdesc:ab2d2718fe5d4f400d91002edf683e8b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this function to signal that the element does not expect any more pads to show up in the current pipeline.  <a href="#ab2d2718fe5d4f400d91002edf683e8b2">More...</a><br /></td></tr>
<tr class="separator:ab2d2718fe5d4f400d91002edf683e8b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa614a038b969d37f5db69999e6200c7a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Element.html#aa614a038b969d37f5db69999e6200c7a">release_request_pad</a> (const Glib::RefPtr&lt; <a class="el" href="classGst_1_1Pad.html">Gst::Pad</a> &gt;&amp; pad)</td></tr>
<tr class="memdesc:aa614a038b969d37f5db69999e6200c7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes the element free the previously requested pad as obtained with <a class="el" href="classGst_1_1Element.html#aea8e7821ecf7acdd24bb08b0e638caa7" title="Retrieves a pad from the element by name (e.g. &quot;src_\\%d&quot;). ">get_request_pad()</a>.  <a href="#aa614a038b969d37f5db69999e6200c7a">More...</a><br /></td></tr>
<tr class="separator:aa614a038b969d37f5db69999e6200c7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61b542aafbb389d69da3033725521d6d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Element.html#a61b542aafbb389d69da3033725521d6d">remove_pad</a> (const Glib::RefPtr&lt; <a class="el" href="classGst_1_1Pad.html">Gst::Pad</a> &gt;&amp; pad)</td></tr>
<tr class="memdesc:a61b542aafbb389d69da3033725521d6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes <em>pad</em> from <em>element</em>.  <a href="#a61b542aafbb389d69da3033725521d6d">More...</a><br /></td></tr>
<tr class="separator:a61b542aafbb389d69da3033725521d6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a490d9605ec092f544df55a54f823637f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGst_1_1Iterator.html">Gst::Iterator</a>&lt; <a class="el" href="classGst_1_1Pad.html">Gst::Pad</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Element.html#a490d9605ec092f544df55a54f823637f">iterate_pads</a> ()</td></tr>
<tr class="memdesc:a490d9605ec092f544df55a54f823637f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves an iterator of <em>element's</em> pads.  <a href="#a490d9605ec092f544df55a54f823637f">More...</a><br /></td></tr>
<tr class="separator:a490d9605ec092f544df55a54f823637f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27893ca54e7f043d420f69a50d1d26ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGst_1_1Iterator.html">Gst::Iterator</a>&lt; const <a class="el" href="classGst_1_1Pad.html">Gst::Pad</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Element.html#a27893ca54e7f043d420f69a50d1d26ed">iterate_pads</a> () const</td></tr>
<tr class="memdesc:a27893ca54e7f043d420f69a50d1d26ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves an iterator of <em>element's</em> pads.  <a href="#a27893ca54e7f043d420f69a50d1d26ed">More...</a><br /></td></tr>
<tr class="separator:a27893ca54e7f043d420f69a50d1d26ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06d06d2217a48a8b136c62ae710681ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGst_1_1Iterator.html">Gst::Iterator</a>&lt; <a class="el" href="classGst_1_1Pad.html">Gst::Pad</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Element.html#a06d06d2217a48a8b136c62ae710681ba">iterate_sink_pads</a> ()</td></tr>
<tr class="memdesc:a06d06d2217a48a8b136c62ae710681ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves an iterator of <em>element's</em> sink pads.  <a href="#a06d06d2217a48a8b136c62ae710681ba">More...</a><br /></td></tr>
<tr class="separator:a06d06d2217a48a8b136c62ae710681ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a695c0edf63f81b41399b8112cc2212c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGst_1_1Iterator.html">Gst::Iterator</a>&lt; const <a class="el" href="classGst_1_1Pad.html">Gst::Pad</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Element.html#a695c0edf63f81b41399b8112cc2212c4">iterate_sink_pads</a> () const</td></tr>
<tr class="memdesc:a695c0edf63f81b41399b8112cc2212c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves an iterator of <em>element's</em> sink pads.  <a href="#a695c0edf63f81b41399b8112cc2212c4">More...</a><br /></td></tr>
<tr class="separator:a695c0edf63f81b41399b8112cc2212c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadadabfccf8ec2ce71da3c8156ef9caf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGst_1_1Iterator.html">Gst::Iterator</a>&lt; <a class="el" href="classGst_1_1Pad.html">Gst::Pad</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Element.html#aadadabfccf8ec2ce71da3c8156ef9caf">iterate_src_pads</a> ()</td></tr>
<tr class="memdesc:aadadabfccf8ec2ce71da3c8156ef9caf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves an iterator of <em>element's</em> source pads.  <a href="#aadadabfccf8ec2ce71da3c8156ef9caf">More...</a><br /></td></tr>
<tr class="separator:aadadabfccf8ec2ce71da3c8156ef9caf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7987f54c0196073393da4b4d411a330f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGst_1_1Iterator.html">Gst::Iterator</a>&lt; const <a class="el" href="classGst_1_1Pad.html">Gst::Pad</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Element.html#a7987f54c0196073393da4b4d411a330f">iterate_src_pads</a> () const</td></tr>
<tr class="memdesc:a7987f54c0196073393da4b4d411a330f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves an iterator of <em>element's</em> source pads.  <a href="#a7987f54c0196073393da4b4d411a330f">More...</a><br /></td></tr>
<tr class="separator:a7987f54c0196073393da4b4d411a330f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82f5083595abf391729cfa6085090dbd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Element.html#a82f5083595abf391729cfa6085090dbd">unlink</a> (const Glib::RefPtr&lt; <a class="el" href="classGst_1_1Element.html">Gst::Element</a> &gt;&amp; dest)</td></tr>
<tr class="memdesc:a82f5083595abf391729cfa6085090dbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlinks all source pads of the source element with all sink pads of the sink element to which they are linked.  <a href="#a82f5083595abf391729cfa6085090dbd">More...</a><br /></td></tr>
<tr class="separator:a82f5083595abf391729cfa6085090dbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacb864fcef4a93fc45a9af3627db0c6b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Element.html#aacb864fcef4a93fc45a9af3627db0c6b">set_context</a> (const Glib::RefPtr&lt; <a class="el" href="classGst_1_1Context.html">Gst::Context</a> &gt;&amp; context)</td></tr>
<tr class="memdesc:aacb864fcef4a93fc45a9af3627db0c6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the context of the element.  <a href="#aacb864fcef4a93fc45a9af3627db0c6b">More...</a><br /></td></tr>
<tr class="separator:aacb864fcef4a93fc45a9af3627db0c6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea27df909b82a7dbcf15d21fe4a6ae17"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Element.html#aea27df909b82a7dbcf15d21fe4a6ae17">link_pads</a> (const Glib::ustring&amp; srcpadname, const Glib::RefPtr&lt; <a class="el" href="classGst_1_1Element.html">Gst::Element</a> &gt;&amp; dest, const Glib::ustring&amp; destpadname)</td></tr>
<tr class="memdesc:aea27df909b82a7dbcf15d21fe4a6ae17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Links the two named pads of the source and destination elements.  <a href="#aea27df909b82a7dbcf15d21fe4a6ae17">More...</a><br /></td></tr>
<tr class="separator:aea27df909b82a7dbcf15d21fe4a6ae17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9a9c3d2b226dfb6920f2e8152ffb5b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Element.html#ae9a9c3d2b226dfb6920f2e8152ffb5b3">unlink_pads</a> (const Glib::ustring&amp; srcpadname, const Glib::RefPtr&lt; <a class="el" href="classGst_1_1Element.html">Gst::Element</a> &gt;&amp; dest, const Glib::ustring&amp; destpadname)</td></tr>
<tr class="memdesc:ae9a9c3d2b226dfb6920f2e8152ffb5b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlinks the two named pads of the source and destination elements.  <a href="#ae9a9c3d2b226dfb6920f2e8152ffb5b3">More...</a><br /></td></tr>
<tr class="separator:ae9a9c3d2b226dfb6920f2e8152ffb5b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4262d8dcba6c3b5ec95555fd1464902c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Element.html#a4262d8dcba6c3b5ec95555fd1464902c">link_pads</a> (const Glib::ustring&amp; srcpadname, const Glib::RefPtr&lt; <a class="el" href="classGst_1_1Element.html">Gst::Element</a> &gt;&amp; dest, const Glib::ustring&amp; destpadname, const Glib::RefPtr&lt; <a class="el" href="classGst_1_1Caps.html">Gst::Caps</a> &gt;&amp; filter)</td></tr>
<tr class="memdesc:a4262d8dcba6c3b5ec95555fd1464902c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Links the two named pads of the source and destination elements.  <a href="#a4262d8dcba6c3b5ec95555fd1464902c">More...</a><br /></td></tr>
<tr class="separator:a4262d8dcba6c3b5ec95555fd1464902c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac94167114b235db33bfc8b1b4ce638b8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Element.html#ac94167114b235db33bfc8b1b4ce638b8">link_pads</a> (const Glib::ustring&amp; srcpadname, const Glib::RefPtr&lt; <a class="el" href="classGst_1_1Element.html">Gst::Element</a> &gt;&amp; dest, const Glib::ustring&amp; destpadname, <a class="el" href="group__gstreamermmEnums.html#ga75cf82fd50d8978c04ce1a111ca9015f">PadLinkCheck</a> flags)</td></tr>
<tr class="memdesc:ac94167114b235db33bfc8b1b4ce638b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Links the two named pads of the source and destination elements.  <a href="#ac94167114b235db33bfc8b1b4ce638b8">More...</a><br /></td></tr>
<tr class="separator:ac94167114b235db33bfc8b1b4ce638b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c7bfc955d8d0152e1af39d6bf0ab6ed"><td class="memItemLeft" align="right" valign="top">Glib::RefPtr&lt; <a class="el" href="classGst_1_1Element.html">Gst::Element</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Element.html#a8c7bfc955d8d0152e1af39d6bf0ab6ed">link</a> (const Glib::RefPtr&lt; <a class="el" href="classGst_1_1Element.html">Gst::Element</a> &gt;&amp; dest, const Glib::RefPtr&lt; <a class="el" href="classGst_1_1Caps.html">Gst::Caps</a> &gt;&amp; filter)</td></tr>
<tr class="memdesc:a8c7bfc955d8d0152e1af39d6bf0ab6ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Links <em>src</em> to <em>dest</em> using the given caps as filtercaps.  <a href="#a8c7bfc955d8d0152e1af39d6bf0ab6ed">More...</a><br /></td></tr>
<tr class="separator:a8c7bfc955d8d0152e1af39d6bf0ab6ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0428a1c8126fc13c27c0df8e713b6aa7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Element.html#a0428a1c8126fc13c27c0df8e713b6aa7">set_base_time</a> (<a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">ClockTime</a> time)</td></tr>
<tr class="memdesc:a0428a1c8126fc13c27c0df8e713b6aa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the base time of an element.  <a href="#a0428a1c8126fc13c27c0df8e713b6aa7">More...</a><br /></td></tr>
<tr class="separator:a0428a1c8126fc13c27c0df8e713b6aa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe5138d41072cfc8c3af1805d44b1e54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">ClockTime</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Element.html#abe5138d41072cfc8c3af1805d44b1e54">get_base_time</a> () const</td></tr>
<tr class="memdesc:abe5138d41072cfc8c3af1805d44b1e54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the base time of the element.  <a href="#abe5138d41072cfc8c3af1805d44b1e54">More...</a><br /></td></tr>
<tr class="separator:abe5138d41072cfc8c3af1805d44b1e54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad01eb1b7406d6bc80de1c5184b8388d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Element.html#ad01eb1b7406d6bc80de1c5184b8388d2">set_start_time</a> (<a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a> time)</td></tr>
<tr class="memdesc:ad01eb1b7406d6bc80de1c5184b8388d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the start time of an element.  <a href="#ad01eb1b7406d6bc80de1c5184b8388d2">More...</a><br /></td></tr>
<tr class="separator:ad01eb1b7406d6bc80de1c5184b8388d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a015311b1871fa70ed8edb6a98fbd423d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Element.html#a015311b1871fa70ed8edb6a98fbd423d">get_start_time</a> () const</td></tr>
<tr class="memdesc:a015311b1871fa70ed8edb6a98fbd423d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the start time of the element.  <a href="#a015311b1871fa70ed8edb6a98fbd423d">More...</a><br /></td></tr>
<tr class="separator:a015311b1871fa70ed8edb6a98fbd423d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3db6b352dc7023246a1dd6592810cccb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Element.html#a3db6b352dc7023246a1dd6592810cccb">set_bus</a> (const Glib::RefPtr&lt; <a class="el" href="classGst_1_1Bus.html">Gst::Bus</a> &gt;&amp; bus)</td></tr>
<tr class="memdesc:a3db6b352dc7023246a1dd6592810cccb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the bus of the element.  <a href="#a3db6b352dc7023246a1dd6592810cccb">More...</a><br /></td></tr>
<tr class="separator:a3db6b352dc7023246a1dd6592810cccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80d48bb2aaf211c177d51d7f250334b7"><td class="memItemLeft" align="right" valign="top">Glib::RefPtr&lt; <a class="el" href="classGst_1_1Bus.html">Gst::Bus</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Element.html#a80d48bb2aaf211c177d51d7f250334b7">get_bus</a> ()</td></tr>
<tr class="memdesc:a80d48bb2aaf211c177d51d7f250334b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the bus of the element.  <a href="#a80d48bb2aaf211c177d51d7f250334b7">More...</a><br /></td></tr>
<tr class="separator:a80d48bb2aaf211c177d51d7f250334b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6ea71674aa04e12781bded3abfe7354"><td class="memItemLeft" align="right" valign="top">Glib::RefPtr&lt; const <a class="el" href="classGst_1_1Bus.html">Gst::Bus</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Element.html#aa6ea71674aa04e12781bded3abfe7354">get_bus</a> () const</td></tr>
<tr class="memdesc:aa6ea71674aa04e12781bded3abfe7354"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the bus of the element.  <a href="#aa6ea71674aa04e12781bded3abfe7354">More...</a><br /></td></tr>
<tr class="separator:aa6ea71674aa04e12781bded3abfe7354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad07256e0790d6781fc6c37c03a2e2d90"><td class="memItemLeft" align="right" valign="top">Glib::RefPtr&lt; <a class="el" href="classGst_1_1ElementFactory.html">Gst::ElementFactory</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Element.html#ad07256e0790d6781fc6c37c03a2e2d90">get_factory</a> ()</td></tr>
<tr class="memdesc:ad07256e0790d6781fc6c37c03a2e2d90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the factory that was used to create this element.  <a href="#ad07256e0790d6781fc6c37c03a2e2d90">More...</a><br /></td></tr>
<tr class="separator:ad07256e0790d6781fc6c37c03a2e2d90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a424089fb124677c5d5c28721fcdfc1c4"><td class="memItemLeft" align="right" valign="top">Glib::RefPtr&lt; const <a class="el" href="classGst_1_1ElementFactory.html">Gst::ElementFactory</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Element.html#a424089fb124677c5d5c28721fcdfc1c4">get_factory</a> () const</td></tr>
<tr class="memdesc:a424089fb124677c5d5c28721fcdfc1c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the factory that was used to create this element.  <a href="#a424089fb124677c5d5c28721fcdfc1c4">More...</a><br /></td></tr>
<tr class="separator:a424089fb124677c5d5c28721fcdfc1c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1a766827de41c955da267718c76db9a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Element.html#ad1a766827de41c955da267718c76db9a">set_clock</a> (const Glib::RefPtr&lt; <a class="el" href="classGst_1_1Clock.html">Gst::Clock</a> &gt;&amp; clock)</td></tr>
<tr class="memdesc:ad1a766827de41c955da267718c76db9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the clock for the element.  <a href="#ad1a766827de41c955da267718c76db9a">More...</a><br /></td></tr>
<tr class="separator:ad1a766827de41c955da267718c76db9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d2e1731488360438dac236fb198e2a0"><td class="memItemLeft" align="right" valign="top">Glib::RefPtr&lt; <a class="el" href="classGst_1_1Clock.html">Gst::Clock</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Element.html#a9d2e1731488360438dac236fb198e2a0">get_clock</a> ()</td></tr>
<tr class="memdesc:a9d2e1731488360438dac236fb198e2a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the currently configured clock of the element.  <a href="#a9d2e1731488360438dac236fb198e2a0">More...</a><br /></td></tr>
<tr class="separator:a9d2e1731488360438dac236fb198e2a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68bbad716c19226980e7189407c96740"><td class="memItemLeft" align="right" valign="top">Glib::RefPtr&lt; const <a class="el" href="classGst_1_1Clock.html">Gst::Clock</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Element.html#a68bbad716c19226980e7189407c96740">get_clock</a> () const</td></tr>
<tr class="memdesc:a68bbad716c19226980e7189407c96740"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the currently configured clock of the element.  <a href="#a68bbad716c19226980e7189407c96740">More...</a><br /></td></tr>
<tr class="separator:a68bbad716c19226980e7189407c96740"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7d7f25e4d79771efe256ff6c40ecbb5"><td class="memItemLeft" align="right" valign="top">Glib::RefPtr&lt; <a class="el" href="classGst_1_1Clock.html">Gst::Clock</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Element.html#af7d7f25e4d79771efe256ff6c40ecbb5">provide_clock</a> ()</td></tr>
<tr class="memdesc:af7d7f25e4d79771efe256ff6c40ecbb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the clock provided by the given element.  <a href="#af7d7f25e4d79771efe256ff6c40ecbb5">More...</a><br /></td></tr>
<tr class="separator:af7d7f25e4d79771efe256ff6c40ecbb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac805b52da039e1b6e21463ec08da6031"><td class="memItemLeft" align="right" valign="top">Glib::RefPtr&lt; const <a class="el" href="classGst_1_1Clock.html">Gst::Clock</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Element.html#ac805b52da039e1b6e21463ec08da6031">provide_clock</a> () const</td></tr>
<tr class="memdesc:ac805b52da039e1b6e21463ec08da6031"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the clock provided by the given element.  <a href="#ac805b52da039e1b6e21463ec08da6031">More...</a><br /></td></tr>
<tr class="separator:ac805b52da039e1b6e21463ec08da6031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f99dbf420c0f34005662dac54fb16b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__gstreamermmEnums.html#gacaa5e30b631a84cf95a0f8918e96f025">StateChangeReturn</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Element.html#a9f99dbf420c0f34005662dac54fb16b7">set_state</a> (<a class="el" href="group__gstreamermmEnums.html#gabb043e1d41659fd842f10949f91e7a7f">State</a> state)</td></tr>
<tr class="memdesc:a9f99dbf420c0f34005662dac54fb16b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the state of the element.  <a href="#a9f99dbf420c0f34005662dac54fb16b7">More...</a><br /></td></tr>
<tr class="separator:a9f99dbf420c0f34005662dac54fb16b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74b7e2811f2d7d4a5ae49e43eace975e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__gstreamermmEnums.html#gacaa5e30b631a84cf95a0f8918e96f025">StateChangeReturn</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Element.html#a74b7e2811f2d7d4a5ae49e43eace975e">get_state</a> (<a class="el" href="group__gstreamermmEnums.html#gabb043e1d41659fd842f10949f91e7a7f">State</a>&amp; state, <a class="el" href="group__gstreamermmEnums.html#gabb043e1d41659fd842f10949f91e7a7f">State</a>&amp; pending, <a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">ClockTime</a> timeout) const</td></tr>
<tr class="memdesc:a74b7e2811f2d7d4a5ae49e43eace975e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the state of the element.  <a href="#a74b7e2811f2d7d4a5ae49e43eace975e">More...</a><br /></td></tr>
<tr class="separator:a74b7e2811f2d7d4a5ae49e43eace975e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a806dffc144477f00ca9a2f34a5b0f8ca"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Element.html#a806dffc144477f00ca9a2f34a5b0f8ca">set_locked_state</a> (gboolean locked_state)</td></tr>
<tr class="memdesc:a806dffc144477f00ca9a2f34a5b0f8ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locks the state of an element, so state changes of the parent don't affect this element anymore.  <a href="#a806dffc144477f00ca9a2f34a5b0f8ca">More...</a><br /></td></tr>
<tr class="separator:a806dffc144477f00ca9a2f34a5b0f8ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a405e45fee201dee89ceb09a053bcc9e7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Element.html#a405e45fee201dee89ceb09a053bcc9e7">is_locked_state</a> () const</td></tr>
<tr class="memdesc:a405e45fee201dee89ceb09a053bcc9e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the state of an element is locked.  <a href="#a405e45fee201dee89ceb09a053bcc9e7">More...</a><br /></td></tr>
<tr class="separator:a405e45fee201dee89ceb09a053bcc9e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaff02239da99117648e17079a9443166"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Element.html#aaff02239da99117648e17079a9443166">abort_state</a> ()</td></tr>
<tr class="memdesc:aaff02239da99117648e17079a9443166"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abort the state change of the element.  <a href="#aaff02239da99117648e17079a9443166">More...</a><br /></td></tr>
<tr class="separator:aaff02239da99117648e17079a9443166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ad12d3eeb5b9842201675492cd19cb4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__gstreamermmEnums.html#gacaa5e30b631a84cf95a0f8918e96f025">StateChangeReturn</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Element.html#a8ad12d3eeb5b9842201675492cd19cb4">continue_state</a> (<a class="el" href="group__gstreamermmEnums.html#gacaa5e30b631a84cf95a0f8918e96f025">StateChangeReturn</a> ret)</td></tr>
<tr class="memdesc:a8ad12d3eeb5b9842201675492cd19cb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Commit the state change of the element and proceed to the next pending state if any.  <a href="#a8ad12d3eeb5b9842201675492cd19cb4">More...</a><br /></td></tr>
<tr class="separator:a8ad12d3eeb5b9842201675492cd19cb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ffbed46992421084ca770c1229c4ba4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Element.html#a4ffbed46992421084ca770c1229c4ba4">lost_state</a> ()</td></tr>
<tr class="memdesc:a4ffbed46992421084ca770c1229c4ba4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Brings the element to the lost state.  <a href="#a4ffbed46992421084ca770c1229c4ba4">More...</a><br /></td></tr>
<tr class="separator:a4ffbed46992421084ca770c1229c4ba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d198b8f460ccc16641d5a21b2975ec0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Element.html#a6d198b8f460ccc16641d5a21b2975ec0">sync_state_with_parent</a> ()</td></tr>
<tr class="memdesc:a6d198b8f460ccc16641d5a21b2975ec0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to change the state of the element to the same as its parent.  <a href="#a6d198b8f460ccc16641d5a21b2975ec0">More...</a><br /></td></tr>
<tr class="separator:a6d198b8f460ccc16641d5a21b2975ec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac014794d6dd75b9896d22682388c8581"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__gstreamermmEnums.html#gacaa5e30b631a84cf95a0f8918e96f025">StateChangeReturn</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Element.html#ac014794d6dd75b9896d22682388c8581">change_state</a> (<a class="el" href="group__gstreamermmEnums.html#ga430f25337ed3cd75da2a088ce56bb3d5">StateChange</a> transition)</td></tr>
<tr class="memdesc:ac014794d6dd75b9896d22682388c8581"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform <em>transition</em> on <em>element</em>.  <a href="#ac014794d6dd75b9896d22682388c8581">More...</a><br /></td></tr>
<tr class="separator:ac014794d6dd75b9896d22682388c8581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45110cdd5580e6fc7415a90ab19df50d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Element.html#a45110cdd5580e6fc7415a90ab19df50d">post_message</a> (int code, int line, <a class="el" href="group__gstreamermmEnums.html#ga704e8de3c3f9698d3c3ca15d61190a86">MessageType</a> type=<a class="el" href="namespaceGst.html#ga704e8de3c3f9698d3c3ca15d61190a86a966198aa626095b0a0237e8e726be298">Gst::MESSAGE_INFO</a>, const Glib::QueryQuark&amp; domain=<a class="el" href="namespaceGst.html#aa186f9e9df937f6c544fce95bf25739b">get_core_error_quark</a>(), const Glib::ustring&amp; text=Glib::ustring(), const Glib::ustring&amp; debug=Glib::ustring(), const Glib::ustring&amp; file=Glib::ustring(), const Glib::ustring&amp; function=Glib::ustring())</td></tr>
<tr class="memdesc:a45110cdd5580e6fc7415a90ab19df50d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Post an error, warning or info message on the bus from inside an element.  <a href="#a45110cdd5580e6fc7415a90ab19df50d">More...</a><br /></td></tr>
<tr class="separator:a45110cdd5580e6fc7415a90ab19df50d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26bbcf496949abc2b8f9f59cf0965f30"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Element.html#a26bbcf496949abc2b8f9f59cf0965f30">post_message</a> (Glib::RefPtr&lt; <a class="el" href="classGst_1_1Message.html">Gst::Message</a> &gt;&amp;&amp; message)</td></tr>
<tr class="memdesc:a26bbcf496949abc2b8f9f59cf0965f30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Post a message on the element's <a class="el" href="classGst_1_1Bus.html" title="A class that encompasses the GStreamer asynchronous message bus subsystem. ">Gst::Bus</a>.  <a href="#a26bbcf496949abc2b8f9f59cf0965f30">More...</a><br /></td></tr>
<tr class="separator:a26bbcf496949abc2b8f9f59cf0965f30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a471ae2f5290f5035f1b7b4de091394d3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Element.html#a471ae2f5290f5035f1b7b4de091394d3">query</a> (const Glib::RefPtr&lt; <a class="el" href="classGst_1_1Query.html">Gst::Query</a> &gt;&amp; query) const</td></tr>
<tr class="memdesc:a471ae2f5290f5035f1b7b4de091394d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a query on the given element.  <a href="#a471ae2f5290f5035f1b7b4de091394d3">More...</a><br /></td></tr>
<tr class="separator:a471ae2f5290f5035f1b7b4de091394d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a820d8c912ac5fd4473b8129024285c8c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Element.html#a820d8c912ac5fd4473b8129024285c8c">query_convert</a> (<a class="el" href="group__gstreamermmEnums.html#ga9aeb4c7c49680888ff819ac95fb13cff">Gst::Format</a> src_format, gint64 src_val, <a class="el" href="group__gstreamermmEnums.html#ga9aeb4c7c49680888ff819ac95fb13cff">Format</a> dest_format, gint64&amp; dest_val) const</td></tr>
<tr class="memdesc:a820d8c912ac5fd4473b8129024285c8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries an element to convert <em>src_val</em> in <em>src_format</em> to <em>dest_format</em>.  <a href="#a820d8c912ac5fd4473b8129024285c8c">More...</a><br /></td></tr>
<tr class="separator:a820d8c912ac5fd4473b8129024285c8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0224cc146c7e4fc0b57271f84803815"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Element.html#ab0224cc146c7e4fc0b57271f84803815">query_position</a> (<a class="el" href="group__gstreamermmEnums.html#ga9aeb4c7c49680888ff819ac95fb13cff">Gst::Format</a> format, gint64&amp; cur) const</td></tr>
<tr class="memdesc:ab0224cc146c7e4fc0b57271f84803815"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries an element (usually top-level pipeline or playbin element) for the stream position in nanoseconds.  <a href="#ab0224cc146c7e4fc0b57271f84803815">More...</a><br /></td></tr>
<tr class="separator:ab0224cc146c7e4fc0b57271f84803815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9466ba6bbd8bb80d48383d78fe1ee835"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Element.html#a9466ba6bbd8bb80d48383d78fe1ee835">query_position</a> (<a class="el" href="group__gstreamermmEnums.html#ga9aeb4c7c49680888ff819ac95fb13cff">Gst::Format</a> format) const</td></tr>
<tr class="memdesc:a9466ba6bbd8bb80d48383d78fe1ee835"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classGst_1_1Element.html#ab0224cc146c7e4fc0b57271f84803815" title="Queries an element (usually top-level pipeline or playbin element) for the stream position in nanosec...">query_position()</a> convenience overload.  <a href="#a9466ba6bbd8bb80d48383d78fe1ee835">More...</a><br /></td></tr>
<tr class="separator:a9466ba6bbd8bb80d48383d78fe1ee835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34be7370445472f300450045f5bbddd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Element.html#ae34be7370445472f300450045f5bbddd">query_duration</a> (<a class="el" href="group__gstreamermmEnums.html#ga9aeb4c7c49680888ff819ac95fb13cff">Gst::Format</a> format, gint64&amp; duration) const</td></tr>
<tr class="memdesc:ae34be7370445472f300450045f5bbddd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries an element (usually top-level pipeline or playbin element) for the total stream duration in nanoseconds.  <a href="#ae34be7370445472f300450045f5bbddd">More...</a><br /></td></tr>
<tr class="separator:ae34be7370445472f300450045f5bbddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77c57f566c07abba61c3bfb5f67f3fe9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Element.html#a77c57f566c07abba61c3bfb5f67f3fe9">query_duration</a> (<a class="el" href="group__gstreamermmEnums.html#ga9aeb4c7c49680888ff819ac95fb13cff">Gst::Format</a> format) const</td></tr>
<tr class="memdesc:a77c57f566c07abba61c3bfb5f67f3fe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classGst_1_1Element.html#ae34be7370445472f300450045f5bbddd" title="Queries an element (usually top-level pipeline or playbin element) for the total stream duration in n...">query_duration()</a> convenience overload.  <a href="#a77c57f566c07abba61c3bfb5f67f3fe9">More...</a><br /></td></tr>
<tr class="separator:a77c57f566c07abba61c3bfb5f67f3fe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3341e4076fd02159a6fe9a2a042f42ae"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Element.html#a3341e4076fd02159a6fe9a2a042f42ae">seek</a> (<a class="el" href="group__gstreamermmEnums.html#ga9aeb4c7c49680888ff819ac95fb13cff">Format</a> format, <a class="el" href="group__gstreamermmEnums.html#ga511d96d2c1136202d0d4b90de2485cf3">SeekFlags</a> seek_flags, gint64 seek_pos)</td></tr>
<tr class="memdesc:a3341e4076fd02159a6fe9a2a042f42ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple API to perform a seek on the given element, meaning it just seeks to the given position relative to the start of the stream.  <a href="#a3341e4076fd02159a6fe9a2a042f42ae">More...</a><br /></td></tr>
<tr class="separator:a3341e4076fd02159a6fe9a2a042f42ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a430a01725519d8b2f6e8dd508284028f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Element.html#a430a01725519d8b2f6e8dd508284028f">seek</a> (double rate, <a class="el" href="group__gstreamermmEnums.html#ga9aeb4c7c49680888ff819ac95fb13cff">Format</a> format, <a class="el" href="group__gstreamermmEnums.html#ga511d96d2c1136202d0d4b90de2485cf3">SeekFlags</a> flags, <a class="el" href="group__gstreamermmEnums.html#gaa7c6407bbc8040f51718d1be753422c0">SeekType</a> cur_type, gint64 cur, <a class="el" href="group__gstreamermmEnums.html#gaa7c6407bbc8040f51718d1be753422c0">SeekType</a> stop_type, gint64 stop)</td></tr>
<tr class="memdesc:a430a01725519d8b2f6e8dd508284028f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a seek event to an element.  <a href="#a430a01725519d8b2f6e8dd508284028f">More...</a><br /></td></tr>
<tr class="separator:a430a01725519d8b2f6e8dd508284028f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01caf7800f24670bd3c152fb2b8f3a2a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Element.html#a01caf7800f24670bd3c152fb2b8f3a2a">send_event</a> (Glib::RefPtr&lt; <a class="el" href="classGst_1_1Event.html">Gst::Event</a> &gt;&amp;&amp; event)</td></tr>
<tr class="memdesc:a01caf7800f24670bd3c152fb2b8f3a2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends an event to an element.  <a href="#a01caf7800f24670bd3c152fb2b8f3a2a">More...</a><br /></td></tr>
<tr class="separator:a01caf7800f24670bd3c152fb2b8f3a2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dee29e72f60948351e91ef45c1cd3fb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Element.html#a2dee29e72f60948351e91ef45c1cd3fb">send_event</a> (const Glib::RefPtr&lt; <a class="el" href="classGst_1_1Event.html">Gst::Event</a> &gt;&amp; event)</td></tr>
<tr class="memdesc:a2dee29e72f60948351e91ef45c1cd3fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classGst_1_1Element.html#a01caf7800f24670bd3c152fb2b8f3a2a" title="Sends an event to an element. ">send_event()</a> convenience overload. Allows to re-use <em>event</em> parameter after function call.  <a href="#a2dee29e72f60948351e91ef45c1cd3fb">More...</a><br /></td></tr>
<tr class="separator:a2dee29e72f60948351e91ef45c1cd3fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30d67deee57effb0283c67a5a21986d2"><td class="memItemLeft" align="right" valign="top">Glib::RefPtr&lt; <a class="el" href="classGst_1_1Context.html">Gst::Context</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Element.html#a30d67deee57effb0283c67a5a21986d2">get_context</a> (const Glib::ustring&amp; context_type)</td></tr>
<tr class="memdesc:a30d67deee57effb0283c67a5a21986d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the context with <em>context_type</em> set on the element or <code>nullptr</code>.  <a href="#a30d67deee57effb0283c67a5a21986d2">More...</a><br /></td></tr>
<tr class="separator:a30d67deee57effb0283c67a5a21986d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7572aa87101ac491c1c80e70c6cb5cb5"><td class="memItemLeft" align="right" valign="top">Glib::RefPtr&lt; <a class="el" href="classGst_1_1Context.html">Gst::Context</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Element.html#a7572aa87101ac491c1c80e70c6cb5cb5">get_context_unlocked</a> (const Glib::ustring&amp; context_type)</td></tr>
<tr class="memdesc:a7572aa87101ac491c1c80e70c6cb5cb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the context with <em>context_type</em> set on the element or <code>nullptr</code>.  <a href="#a7572aa87101ac491c1c80e70c6cb5cb5">More...</a><br /></td></tr>
<tr class="separator:a7572aa87101ac491c1c80e70c6cb5cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a563570e8ba23c4938accf87cff9b2c47"><td class="memItemLeft" align="right" valign="top"><a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00965.html">std::vector</a>&lt; Glib::RefPtr&lt; <a class="el" href="classGst_1_1Context.html">Gst::Context</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Element.html#a563570e8ba23c4938accf87cff9b2c47">get_contexts</a> ()</td></tr>
<tr class="memdesc:a563570e8ba23c4938accf87cff9b2c47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the contexts set on the element.  <a href="#a563570e8ba23c4938accf87cff9b2c47">More...</a><br /></td></tr>
<tr class="separator:a563570e8ba23c4938accf87cff9b2c47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a419abecd2a358f6157ba82dbb2f1e067"><td class="memItemLeft" align="right" valign="top">Glib::SignalProxy&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Element.html#a419abecd2a358f6157ba82dbb2f1e067">signal_no_more_pads</a> ()</td></tr>
<tr class="separator:a419abecd2a358f6157ba82dbb2f1e067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaf2d91e5aafe78141c3cf8c80724938"><td class="memItemLeft" align="right" valign="top">Glib::SignalProxy&lt; void, const Glib::RefPtr&lt; <a class="el" href="classGst_1_1Pad.html">Gst::Pad</a> &gt;&amp;&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Element.html#aaaf2d91e5aafe78141c3cf8c80724938">signal_pad_added</a> ()</td></tr>
<tr class="separator:aaaf2d91e5aafe78141c3cf8c80724938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00f82141e3f402192b056fcb42aa24d4"><td class="memItemLeft" align="right" valign="top">Glib::SignalProxy&lt; void, const Glib::RefPtr&lt; <a class="el" href="classGst_1_1Pad.html">Gst::Pad</a> &gt;&amp;&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Element.html#a00f82141e3f402192b056fcb42aa24d4">signal_pad_removed</a> ()</td></tr>
<tr class="separator:a00f82141e3f402192b056fcb42aa24d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17cc02bebfd099a1330a59467cef3f3b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Element.html#a17cc02bebfd099a1330a59467cef3f3b">release_pad_vfunc</a> (const Glib::RefPtr&lt; <a class="el" href="classGst_1_1Pad.html">Gst::Pad</a> &gt;&amp; pad)</td></tr>
<tr class="memdesc:a17cc02bebfd099a1330a59467cef3f3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a request pad is to be released.  <a href="#a17cc02bebfd099a1330a59467cef3f3b">More...</a><br /></td></tr>
<tr class="separator:a17cc02bebfd099a1330a59467cef3f3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab459dfdb70ef2a61202e8ff467595763"><td class="memItemLeft" align="right" valign="top">virtual Glib::RefPtr&lt; <a class="el" href="classGst_1_1Pad.html">Gst::Pad</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Element.html#ab459dfdb70ef2a61202e8ff467595763">request_new_pad_vfunc</a> (Glib::RefPtr&lt; <a class="el" href="classGst_1_1PadTemplate.html">Gst::PadTemplate</a> &gt; templ, const Glib::ustring&amp; name, const Glib::RefPtr&lt; const <a class="el" href="classGst_1_1Caps.html">Gst::Caps</a> &gt;&amp; caps)</td></tr>
<tr class="memdesc:ab459dfdb70ef2a61202e8ff467595763"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a new pad is requested.  <a href="#ab459dfdb70ef2a61202e8ff467595763">More...</a><br /></td></tr>
<tr class="separator:ab459dfdb70ef2a61202e8ff467595763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c9be14c0792eae794d650ca486dfbe6"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__gstreamermmEnums.html#gacaa5e30b631a84cf95a0f8918e96f025">StateChangeReturn</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Element.html#a7c9be14c0792eae794d650ca486dfbe6">get_state_vfunc</a> (<a class="el" href="group__gstreamermmEnums.html#gabb043e1d41659fd842f10949f91e7a7f">State</a>&amp; state, <a class="el" href="group__gstreamermmEnums.html#gabb043e1d41659fd842f10949f91e7a7f">State</a>&amp; pending, <a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">ClockTime</a> timeout) const</td></tr>
<tr class="memdesc:a7c9be14c0792eae794d650ca486dfbe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the state of the element.  <a href="#a7c9be14c0792eae794d650ca486dfbe6">More...</a><br /></td></tr>
<tr class="separator:a7c9be14c0792eae794d650ca486dfbe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab78ac5519d084e4d06c913c276f2d11b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__gstreamermmEnums.html#gacaa5e30b631a84cf95a0f8918e96f025">StateChangeReturn</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Element.html#ab78ac5519d084e4d06c913c276f2d11b">set_state_vfunc</a> (<a class="el" href="group__gstreamermmEnums.html#gabb043e1d41659fd842f10949f91e7a7f">State</a> state)</td></tr>
<tr class="memdesc:ab78ac5519d084e4d06c913c276f2d11b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a new state on the element.  <a href="#ab78ac5519d084e4d06c913c276f2d11b">More...</a><br /></td></tr>
<tr class="separator:ab78ac5519d084e4d06c913c276f2d11b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a0c04186513d05eb90fa71001639bc7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__gstreamermmEnums.html#gacaa5e30b631a84cf95a0f8918e96f025">StateChangeReturn</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Element.html#a1a0c04186513d05eb90fa71001639bc7">change_state_vfunc</a> (<a class="el" href="group__gstreamermmEnums.html#ga430f25337ed3cd75da2a088ce56bb3d5">StateChange</a> transition)</td></tr>
<tr class="memdesc:a1a0c04186513d05eb90fa71001639bc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by set_state to perform an incremental state change.  <a href="#a1a0c04186513d05eb90fa71001639bc7">More...</a><br /></td></tr>
<tr class="separator:a1a0c04186513d05eb90fa71001639bc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad784f418931639b085b3cf567c175e5c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Element.html#ad784f418931639b085b3cf567c175e5c">state_changed_vfunc</a> (<a class="el" href="group__gstreamermmEnums.html#gabb043e1d41659fd842f10949f91e7a7f">Gst::State</a> oldstate, <a class="el" href="group__gstreamermmEnums.html#gabb043e1d41659fd842f10949f91e7a7f">Gst::State</a> newstate, <a class="el" href="group__gstreamermmEnums.html#gabb043e1d41659fd842f10949f91e7a7f">Gst::State</a> pending)</td></tr>
<tr class="memdesc:ad784f418931639b085b3cf567c175e5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called immediately after a new state was set.  <a href="#ad784f418931639b085b3cf567c175e5c">More...</a><br /></td></tr>
<tr class="separator:ad784f418931639b085b3cf567c175e5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a404fa6688b0f042f1dc46d2e22fc7dbc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Element.html#a404fa6688b0f042f1dc46d2e22fc7dbc">set_bus_vfunc</a> (const Glib::RefPtr&lt; <a class="el" href="classGst_1_1Bus.html">Gst::Bus</a> &gt;&amp; bus)</td></tr>
<tr class="memdesc:a404fa6688b0f042f1dc46d2e22fc7dbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a <a class="el" href="classGst_1_1Bus.html" title="A class that encompasses the GStreamer asynchronous message bus subsystem. ">Gst::Bus</a> on the element.  <a href="#a404fa6688b0f042f1dc46d2e22fc7dbc">More...</a><br /></td></tr>
<tr class="separator:a404fa6688b0f042f1dc46d2e22fc7dbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbd6faca7b79fd358af5a6a0b91a8600"><td class="memItemLeft" align="right" valign="top">virtual Glib::RefPtr&lt; <a class="el" href="classGst_1_1Clock.html">Gst::Clock</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Element.html#acbd6faca7b79fd358af5a6a0b91a8600">provide_clock_vfunc</a> ()</td></tr>
<tr class="memdesc:acbd6faca7b79fd358af5a6a0b91a8600"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the <a class="el" href="classGst_1_1Clock.html" title="Abstract class for global clocks GStreamer uses a global clock to synchronize the plugins in a pipeli...">Gst::Clock</a> provided by the element.  <a href="#acbd6faca7b79fd358af5a6a0b91a8600">More...</a><br /></td></tr>
<tr class="separator:acbd6faca7b79fd358af5a6a0b91a8600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e0baa09a835bdcef521b5f6aa0a387f"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Element.html#a4e0baa09a835bdcef521b5f6aa0a387f">set_clock_vfunc</a> (const Glib::RefPtr&lt; <a class="el" href="classGst_1_1Clock.html">Gst::Clock</a> &gt;&amp; clock)</td></tr>
<tr class="memdesc:a4e0baa09a835bdcef521b5f6aa0a387f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the <a class="el" href="classGst_1_1Clock.html" title="Abstract class for global clocks GStreamer uses a global clock to synchronize the plugins in a pipeli...">Gst::Clock</a> on the element.  <a href="#a4e0baa09a835bdcef521b5f6aa0a387f">More...</a><br /></td></tr>
<tr class="separator:a4e0baa09a835bdcef521b5f6aa0a387f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c6eb96eca5dbffe165cc7f8f00f0de6"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Element.html#a2c6eb96eca5dbffe165cc7f8f00f0de6">send_event_vfunc</a> (const Glib::RefPtr&lt; <a class="el" href="classGst_1_1Event.html">Gst::Event</a> &gt;&amp; event)</td></tr>
<tr class="memdesc:a2c6eb96eca5dbffe165cc7f8f00f0de6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a <a class="el" href="classGst_1_1Event.html" title="A class that represents events that are passed up and down a pipeline. ">Gst::Event</a> to the element.  <a href="#a2c6eb96eca5dbffe165cc7f8f00f0de6">More...</a><br /></td></tr>
<tr class="separator:a2c6eb96eca5dbffe165cc7f8f00f0de6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac79bb6d05740a2a3c1a0e79cad55e527"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Element.html#ac79bb6d05740a2a3c1a0e79cad55e527">query_vfunc</a> (const Glib::RefPtr&lt; <a class="el" href="classGst_1_1Query.html">Gst::Query</a> &gt;&amp;<a class="el" href="classGst_1_1Element.html#a471ae2f5290f5035f1b7b4de091394d3">query</a>) const</td></tr>
<tr class="memdesc:ac79bb6d05740a2a3c1a0e79cad55e527"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a <a class="el" href="classGst_1_1Query.html" title="A class used to perform queries on pads and elements. ">Gst::Query</a> on the element.  <a href="#ac79bb6d05740a2a3c1a0e79cad55e527">More...</a><br /></td></tr>
<tr class="separator:ac79bb6d05740a2a3c1a0e79cad55e527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a910b5a5812341da6a9568f59dc9d51"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Element.html#a0a910b5a5812341da6a9568f59dc9d51">set_context_vfunc</a> (const Glib::RefPtr&lt; <a class="el" href="classGst_1_1Context.html">Gst::Context</a> &gt;&amp; context)</td></tr>
<tr class="memdesc:a0a910b5a5812341da6a9568f59dc9d51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a <a class="el" href="classGst_1_1Context.html" title="Lightweight objects to represent element contexts. ">Gst::Context</a> on the element.  <a href="#a0a910b5a5812341da6a9568f59dc9d51">More...</a><br /></td></tr>
<tr class="separator:a0a910b5a5812341da6a9568f59dc9d51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac04bed52183cca8e02e6d6dfb99318b5"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Element.html#ac04bed52183cca8e02e6d6dfb99318b5">post_message_vfunc</a> (const Glib::RefPtr&lt; <a class="el" href="classGst_1_1Message.html">Gst::Message</a> &gt;&amp; message)</td></tr>
<tr class="memdesc:ac04bed52183cca8e02e6d6dfb99318b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a message is posted on the element.  <a href="#ac04bed52183cca8e02e6d6dfb99318b5">More...</a><br /></td></tr>
<tr class="separator:ac04bed52183cca8e02e6d6dfb99318b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58917308a93eb2029f850c34510e3ff3"><td class="memItemLeft" align="right" valign="top">Glib::RefPtr&lt; <a class="el" href="classGst_1_1PadTemplate.html">Gst::PadTemplate</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Element.html#a58917308a93eb2029f850c34510e3ff3">get_pad_template</a> (const Glib::ustring&amp; factory_name) const</td></tr>
<tr class="separator:a58917308a93eb2029f850c34510e3ff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2c85c09f45a4af156b3da9b0aeb0492"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa2c85c09f45a4af156b3da9b0aeb0492"><td class="memTemplItemLeft" align="right" valign="top">Glib::RefPtr&lt; <a class="el" href="classGst_1_1Element.html">Gst::Element</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classGst_1_1Element.html#aa2c85c09f45a4af156b3da9b0aeb0492">property</a> (const Glib::ustring&amp; name, const T&amp; value)</td></tr>
<tr class="memdesc:aa2c85c09f45a4af156b3da9b0aeb0492"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets specified property.  <a href="#aa2c85c09f45a4af156b3da9b0aeb0492">More...</a><br /></td></tr>
<tr class="separator:aa2c85c09f45a4af156b3da9b0aeb0492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classGst_1_1Object"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classGst_1_1Object')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classGst_1_1Object.html">Gst::Object</a></td></tr>
<tr class="memitem:a81151161e4abf313e76ab35fa73d1293 inherit pub_methods_classGst_1_1Object"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Object.html#a81151161e4abf313e76ab35fa73d1293">Object</a> (<a class="el" href="classGst_1_1Object.html">Object</a>&amp;&amp; src) noexcept</td></tr>
<tr class="separator:a81151161e4abf313e76ab35fa73d1293 inherit pub_methods_classGst_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3b8964b21574cae10f31d80061c7e40 inherit pub_methods_classGst_1_1Object"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGst_1_1Object.html">Object</a>&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Object.html#af3b8964b21574cae10f31d80061c7e40">operator=</a> (<a class="el" href="classGst_1_1Object.html">Object</a>&amp;&amp; src) noexcept</td></tr>
<tr class="separator:af3b8964b21574cae10f31d80061c7e40 inherit pub_methods_classGst_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4ecd638aea2e21916e2e21429eef97a inherit pub_methods_classGst_1_1Object"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Object.html#ad4ecd638aea2e21916e2e21429eef97a">~Object</a> () noexcept override</td></tr>
<tr class="separator:ad4ecd638aea2e21916e2e21429eef97a inherit pub_methods_classGst_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d889e949c76aa3ab4490026d6aca8ca inherit pub_methods_classGst_1_1Object"><td class="memItemLeft" align="right" valign="top">GstObject*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Object.html#a3d889e949c76aa3ab4490026d6aca8ca">gobj</a> ()</td></tr>
<tr class="memdesc:a3d889e949c76aa3ab4490026d6aca8ca inherit pub_methods_classGst_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the underlying C GObject.  <a href="classGst_1_1Object.html#a3d889e949c76aa3ab4490026d6aca8ca">More...</a><br /></td></tr>
<tr class="separator:a3d889e949c76aa3ab4490026d6aca8ca inherit pub_methods_classGst_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6a4514f948551dcc2e45b3636b490fe inherit pub_methods_classGst_1_1Object"><td class="memItemLeft" align="right" valign="top">const GstObject*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Object.html#ad6a4514f948551dcc2e45b3636b490fe">gobj</a> () const</td></tr>
<tr class="memdesc:ad6a4514f948551dcc2e45b3636b490fe inherit pub_methods_classGst_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the underlying C GObject.  <a href="classGst_1_1Object.html#ad6a4514f948551dcc2e45b3636b490fe">More...</a><br /></td></tr>
<tr class="separator:ad6a4514f948551dcc2e45b3636b490fe inherit pub_methods_classGst_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63d7202d3eb47c81ffc3ac16a895e9d1 inherit pub_methods_classGst_1_1Object"><td class="memItemLeft" align="right" valign="top">GstObject*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Object.html#a63d7202d3eb47c81ffc3ac16a895e9d1">gobj_copy</a> ()</td></tr>
<tr class="memdesc:a63d7202d3eb47c81ffc3ac16a895e9d1 inherit pub_methods_classGst_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the underlying C instance. The caller is responsible for unrefing it. Use when directly setting fields in structs.  <a href="classGst_1_1Object.html#a63d7202d3eb47c81ffc3ac16a895e9d1">More...</a><br /></td></tr>
<tr class="separator:a63d7202d3eb47c81ffc3ac16a895e9d1 inherit pub_methods_classGst_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae96d8781fb1614a5a97e2a6f39e823b3 inherit pub_methods_classGst_1_1Object"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Object.html#ae96d8781fb1614a5a97e2a6f39e823b3">is_element</a> () const</td></tr>
<tr class="separator:ae96d8781fb1614a5a97e2a6f39e823b3 inherit pub_methods_classGst_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a906d1bd351d5f20a38964d6ab9a2c845 inherit pub_methods_classGst_1_1Object"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Object.html#a906d1bd351d5f20a38964d6ab9a2c845">is_element_factory</a> () const</td></tr>
<tr class="separator:a906d1bd351d5f20a38964d6ab9a2c845 inherit pub_methods_classGst_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb1cbea0f958a71af207f46d8b4ff5fc inherit pub_methods_classGst_1_1Object"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Object.html#acb1cbea0f958a71af207f46d8b4ff5fc">is_pad</a> () const</td></tr>
<tr class="separator:acb1cbea0f958a71af207f46d8b4ff5fc inherit pub_methods_classGst_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b577e25de7574fa1c0b98db8072bc47 inherit pub_methods_classGst_1_1Object"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Object.html#a8b577e25de7574fa1c0b98db8072bc47">is_pad_template</a> () const</td></tr>
<tr class="separator:a8b577e25de7574fa1c0b98db8072bc47 inherit pub_methods_classGst_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc51ab9f7e9c1b002502bcbcb747fa78 inherit pub_methods_classGst_1_1Object"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Object.html#afc51ab9f7e9c1b002502bcbcb747fa78">is_bin</a> () const</td></tr>
<tr class="separator:afc51ab9f7e9c1b002502bcbcb747fa78 inherit pub_methods_classGst_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac824b4d7a69a1068ed3614c8c0bdd24 inherit pub_methods_classGst_1_1Object"><td class="memItemLeft" align="right" valign="top">guint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Object.html#aac824b4d7a69a1068ed3614c8c0bdd24">get_flags</a> () const</td></tr>
<tr class="memdesc:aac824b4d7a69a1068ed3614c8c0bdd24 inherit pub_methods_classGst_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the entire set of flags for the object.  <a href="classGst_1_1Object.html#aac824b4d7a69a1068ed3614c8c0bdd24">More...</a><br /></td></tr>
<tr class="separator:aac824b4d7a69a1068ed3614c8c0bdd24 inherit pub_methods_classGst_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91745b6c35472bc28fde65c770444478 inherit pub_methods_classGst_1_1Object"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Object.html#a91745b6c35472bc28fde65c770444478">set_name</a> (const Glib::ustring&amp; name)</td></tr>
<tr class="memdesc:a91745b6c35472bc28fde65c770444478 inherit pub_methods_classGst_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the name of <em>object</em>, or gives <em>object</em> a guaranteed unique name (if <em>name</em> is <code>nullptr</code>).  <a href="classGst_1_1Object.html#a91745b6c35472bc28fde65c770444478">More...</a><br /></td></tr>
<tr class="separator:a91745b6c35472bc28fde65c770444478 inherit pub_methods_classGst_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8a7e72f2bf6539244668d7238d46159 inherit pub_methods_classGst_1_1Object"><td class="memItemLeft" align="right" valign="top">Glib::ustring&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Object.html#ab8a7e72f2bf6539244668d7238d46159">get_name</a> () const</td></tr>
<tr class="memdesc:ab8a7e72f2bf6539244668d7238d46159 inherit pub_methods_classGst_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the name of <em>object</em>.  <a href="classGst_1_1Object.html#ab8a7e72f2bf6539244668d7238d46159">More...</a><br /></td></tr>
<tr class="separator:ab8a7e72f2bf6539244668d7238d46159 inherit pub_methods_classGst_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09a2f2fcfb0fabee2597b34a0b7c3fe4 inherit pub_methods_classGst_1_1Object"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Object.html#a09a2f2fcfb0fabee2597b34a0b7c3fe4">set_parent</a> (const Glib::RefPtr&lt; <a class="el" href="classGst_1_1Object.html">Gst::Object</a> &gt;&amp; parent)</td></tr>
<tr class="memdesc:a09a2f2fcfb0fabee2597b34a0b7c3fe4 inherit pub_methods_classGst_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the parent of <em>object</em> to <em>parent</em>.  <a href="classGst_1_1Object.html#a09a2f2fcfb0fabee2597b34a0b7c3fe4">More...</a><br /></td></tr>
<tr class="separator:a09a2f2fcfb0fabee2597b34a0b7c3fe4 inherit pub_methods_classGst_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a303610665c252f733808e5653703f6a8 inherit pub_methods_classGst_1_1Object"><td class="memItemLeft" align="right" valign="top">Glib::RefPtr&lt; <a class="el" href="classGst_1_1Object.html">Gst::Object</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Object.html#a303610665c252f733808e5653703f6a8">get_parent</a> ()</td></tr>
<tr class="memdesc:a303610665c252f733808e5653703f6a8 inherit pub_methods_classGst_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the parent of <em>object</em>.  <a href="classGst_1_1Object.html#a303610665c252f733808e5653703f6a8">More...</a><br /></td></tr>
<tr class="separator:a303610665c252f733808e5653703f6a8 inherit pub_methods_classGst_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f8dc04241bee2beb2e3b8e0887bf240 inherit pub_methods_classGst_1_1Object"><td class="memItemLeft" align="right" valign="top">Glib::RefPtr&lt; const <a class="el" href="classGst_1_1Object.html">Gst::Object</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Object.html#a8f8dc04241bee2beb2e3b8e0887bf240">get_parent</a> () const</td></tr>
<tr class="memdesc:a8f8dc04241bee2beb2e3b8e0887bf240 inherit pub_methods_classGst_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the parent of <em>object</em>.  <a href="classGst_1_1Object.html#a8f8dc04241bee2beb2e3b8e0887bf240">More...</a><br /></td></tr>
<tr class="separator:a8f8dc04241bee2beb2e3b8e0887bf240 inherit pub_methods_classGst_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45b87529c337e40f03e34bca450e41bc inherit pub_methods_classGst_1_1Object"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Object.html#a45b87529c337e40f03e34bca450e41bc">unparent</a> ()</td></tr>
<tr class="memdesc:a45b87529c337e40f03e34bca450e41bc inherit pub_methods_classGst_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the parent of <em>object</em>, removing the associated reference.  <a href="classGst_1_1Object.html#a45b87529c337e40f03e34bca450e41bc">More...</a><br /></td></tr>
<tr class="separator:a45b87529c337e40f03e34bca450e41bc inherit pub_methods_classGst_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71dd4f21c9c28e44bbb102d4020d6fb9 inherit pub_methods_classGst_1_1Object"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Object.html#a71dd4f21c9c28e44bbb102d4020d6fb9">set_control_rate</a> (<a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a> control_rate)</td></tr>
<tr class="memdesc:a71dd4f21c9c28e44bbb102d4020d6fb9 inherit pub_methods_classGst_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the control-rate for this <em>object</em>.  <a href="classGst_1_1Object.html#a71dd4f21c9c28e44bbb102d4020d6fb9">More...</a><br /></td></tr>
<tr class="separator:a71dd4f21c9c28e44bbb102d4020d6fb9 inherit pub_methods_classGst_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f61c7a77c8915f25ea9630e316e64d1 inherit pub_methods_classGst_1_1Object"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Object.html#a0f61c7a77c8915f25ea9630e316e64d1">get_control_rate</a> () const</td></tr>
<tr class="memdesc:a0f61c7a77c8915f25ea9630e316e64d1 inherit pub_methods_classGst_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the control-rate for this <em>object</em>.  <a href="classGst_1_1Object.html#a0f61c7a77c8915f25ea9630e316e64d1">More...</a><br /></td></tr>
<tr class="separator:a0f61c7a77c8915f25ea9630e316e64d1 inherit pub_methods_classGst_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ecaa24f220031816a05cd2f332e5149 inherit pub_methods_classGst_1_1Object"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Object.html#a6ecaa24f220031816a05cd2f332e5149">suggest_next_sync</a> () const</td></tr>
<tr class="memdesc:a6ecaa24f220031816a05cd2f332e5149 inherit pub_methods_classGst_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a suggestion for timestamps where buffers should be split to get best controller results.  <a href="classGst_1_1Object.html#a6ecaa24f220031816a05cd2f332e5149">More...</a><br /></td></tr>
<tr class="separator:a6ecaa24f220031816a05cd2f332e5149 inherit pub_methods_classGst_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ffd67bd304da65bec7966e0618318fa inherit pub_methods_classGst_1_1Object"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Object.html#a1ffd67bd304da65bec7966e0618318fa">sync_values</a> (<a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a> timestamp)</td></tr>
<tr class="memdesc:a1ffd67bd304da65bec7966e0618318fa inherit pub_methods_classGst_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the properties of the object, according to the Gst::ControlSources that (maybe) handle them and for the given timestamp.  <a href="classGst_1_1Object.html#a1ffd67bd304da65bec7966e0618318fa">More...</a><br /></td></tr>
<tr class="separator:a1ffd67bd304da65bec7966e0618318fa inherit pub_methods_classGst_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50cf4988393c9a170d196640f4e57384 inherit pub_methods_classGst_1_1Object"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Object.html#a50cf4988393c9a170d196640f4e57384">set_control_bindings_disabled</a> (bool disabled)</td></tr>
<tr class="memdesc:a50cf4988393c9a170d196640f4e57384 inherit pub_methods_classGst_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to disable all controlled properties of the <em>object</em> for some time, i.e. <a class="el" href="classGst_1_1Object.html#a1ffd67bd304da65bec7966e0618318fa" title="Sets the properties of the object, according to the Gst::ControlSources that (maybe) handle them and ...">sync_values()</a> will do nothing.  <a href="classGst_1_1Object.html#a50cf4988393c9a170d196640f4e57384">More...</a><br /></td></tr>
<tr class="separator:a50cf4988393c9a170d196640f4e57384 inherit pub_methods_classGst_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7802f29724a1d24e9b317793c58d4b10 inherit pub_methods_classGst_1_1Object"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Object.html#a7802f29724a1d24e9b317793c58d4b10">has_asctive_control_bindings</a> () const</td></tr>
<tr class="memdesc:a7802f29724a1d24e9b317793c58d4b10 inherit pub_methods_classGst_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classGst_1_1Check.html">Check</a> if the <em>object</em> has an active controlled properties.  <a href="classGst_1_1Object.html#a7802f29724a1d24e9b317793c58d4b10">More...</a><br /></td></tr>
<tr class="separator:a7802f29724a1d24e9b317793c58d4b10 inherit pub_methods_classGst_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee1a36004d2f70fcafb2a69a10c9bae6 inherit pub_methods_classGst_1_1Object"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Object.html#aee1a36004d2f70fcafb2a69a10c9bae6">has_ancestor</a> (const Glib::RefPtr&lt; const <a class="el" href="classGst_1_1Object.html">Gst::Object</a> &gt;&amp; ancestor) const</td></tr>
<tr class="memdesc:aee1a36004d2f70fcafb2a69a10c9bae6 inherit pub_methods_classGst_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classGst_1_1Check.html">Check</a> if <em>object</em> has an ancestor <em>ancestor</em> somewhere up in the hierarchy.  <a href="classGst_1_1Object.html#aee1a36004d2f70fcafb2a69a10c9bae6">More...</a><br /></td></tr>
<tr class="separator:aee1a36004d2f70fcafb2a69a10c9bae6 inherit pub_methods_classGst_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e8abe2e2e7cda5b26ee7a7e52320890 inherit pub_methods_classGst_1_1Object"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Object.html#a4e8abe2e2e7cda5b26ee7a7e52320890">has_as_ancestor</a> (const Glib::RefPtr&lt; <a class="el" href="classGst_1_1Object.html">Gst::Object</a> &gt;&amp; ancestor) const</td></tr>
<tr class="memdesc:a4e8abe2e2e7cda5b26ee7a7e52320890 inherit pub_methods_classGst_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classGst_1_1Check.html">Check</a> if <em>object</em> has an ancestor <em>ancestor</em> somewhere up in the hierarchy.  <a href="classGst_1_1Object.html#a4e8abe2e2e7cda5b26ee7a7e52320890">More...</a><br /></td></tr>
<tr class="separator:a4e8abe2e2e7cda5b26ee7a7e52320890 inherit pub_methods_classGst_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaaa4fbe4078d9ceadd45435ed0f079d inherit pub_methods_classGst_1_1Object"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Object.html#abaaa4fbe4078d9ceadd45435ed0f079d">has_as_parent</a> (const Glib::RefPtr&lt; <a class="el" href="classGst_1_1Object.html">Gst::Object</a> &gt;&amp; parent) const</td></tr>
<tr class="memdesc:abaaa4fbe4078d9ceadd45435ed0f079d inherit pub_methods_classGst_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classGst_1_1Check.html">Check</a> if <em>parent</em> is the parent of <em>object</em>.  <a href="classGst_1_1Object.html#abaaa4fbe4078d9ceadd45435ed0f079d">More...</a><br /></td></tr>
<tr class="separator:abaaa4fbe4078d9ceadd45435ed0f079d inherit pub_methods_classGst_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e2da47b8e8eb7c48e6e6ec1a4f6ac94 inherit pub_methods_classGst_1_1Object"><td class="memItemLeft" align="right" valign="top">Glib::ustring&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Object.html#a4e2da47b8e8eb7c48e6e6ec1a4f6ac94">get_path_string</a> ()</td></tr>
<tr class="memdesc:a4e2da47b8e8eb7c48e6e6ec1a4f6ac94 inherit pub_methods_classGst_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a string describing the path of <em>object</em> in the object hierarchy.  <a href="classGst_1_1Object.html#a4e2da47b8e8eb7c48e6e6ec1a4f6ac94">More...</a><br /></td></tr>
<tr class="separator:a4e2da47b8e8eb7c48e6e6ec1a4f6ac94 inherit pub_methods_classGst_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d51c0f61b8ef58eafb2a2f2e59b1f74 inherit pub_methods_classGst_1_1Object"><td class="memItemLeft" align="right" valign="top">Glib::PropertyProxy&lt; Glib::ustring &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Object.html#a3d51c0f61b8ef58eafb2a2f2e59b1f74">property_name</a> ()</td></tr>
<tr class="memdesc:a3d51c0f61b8ef58eafb2a2f2e59b1f74 inherit pub_methods_classGst_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">The name of the object.  <a href="classGst_1_1Object.html#a3d51c0f61b8ef58eafb2a2f2e59b1f74">More...</a><br /></td></tr>
<tr class="separator:a3d51c0f61b8ef58eafb2a2f2e59b1f74 inherit pub_methods_classGst_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf94eb5a427a1e7d2907caf50a8cf7e2 inherit pub_methods_classGst_1_1Object"><td class="memItemLeft" align="right" valign="top">Glib::PropertyProxy_ReadOnly&lt; Glib::ustring &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Object.html#adf94eb5a427a1e7d2907caf50a8cf7e2">property_name</a> () const</td></tr>
<tr class="memdesc:adf94eb5a427a1e7d2907caf50a8cf7e2 inherit pub_methods_classGst_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">The name of the object.  <a href="classGst_1_1Object.html#adf94eb5a427a1e7d2907caf50a8cf7e2">More...</a><br /></td></tr>
<tr class="separator:adf94eb5a427a1e7d2907caf50a8cf7e2 inherit pub_methods_classGst_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73a0272f16e1481f54150b1b412fa88c inherit pub_methods_classGst_1_1Object"><td class="memItemLeft" align="right" valign="top">Glib::PropertyProxy&lt; Glib::RefPtr&lt; <a class="el" href="classGst_1_1Object.html">Gst::Object</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Object.html#a73a0272f16e1481f54150b1b412fa88c">property_parent</a> ()</td></tr>
<tr class="memdesc:a73a0272f16e1481f54150b1b412fa88c inherit pub_methods_classGst_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">The parent of the object.  <a href="classGst_1_1Object.html#a73a0272f16e1481f54150b1b412fa88c">More...</a><br /></td></tr>
<tr class="separator:a73a0272f16e1481f54150b1b412fa88c inherit pub_methods_classGst_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa675064df0fcf0aaee34db75b8a6005b inherit pub_methods_classGst_1_1Object"><td class="memItemLeft" align="right" valign="top">Glib::PropertyProxy_ReadOnly&lt; Glib::RefPtr&lt; <a class="el" href="classGst_1_1Object.html">Gst::Object</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Object.html#aa675064df0fcf0aaee34db75b8a6005b">property_parent</a> () const</td></tr>
<tr class="memdesc:aa675064df0fcf0aaee34db75b8a6005b inherit pub_methods_classGst_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">The parent of the object.  <a href="classGst_1_1Object.html#aa675064df0fcf0aaee34db75b8a6005b">More...</a><br /></td></tr>
<tr class="separator:aa675064df0fcf0aaee34db75b8a6005b inherit pub_methods_classGst_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0fe96dbc1176a937bdb829ad3334afb inherit pub_methods_classGst_1_1Object"><td class="memItemLeft" align="right" valign="top">Glib::SignalProxy&lt; void, const Glib::RefPtr&lt; <a class="el" href="classGst_1_1Object.html">Gst::Object</a> &gt;&amp;, GParamSpec*&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Object.html#ac0fe96dbc1176a937bdb829ad3334afb">signal_deep_notify</a> ()</td></tr>
<tr class="separator:ac0fe96dbc1176a937bdb829ad3334afb inherit pub_methods_classGst_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc2d69664a0d2bc0176e3421ff4b351f inherit pub_methods_classGst_1_1Object"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Object.html#afc2d69664a0d2bc0176e3421ff4b351f">get_refcount</a> () const</td></tr>
<tr class="separator:afc2d69664a0d2bc0176e3421ff4b351f inherit pub_methods_classGst_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a26c4c58db02fb60a08349360967532df"><td class="memItemLeft" align="right" valign="top">static GType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Element.html#a26c4c58db02fb60a08349360967532df">get_type</a> ()</td></tr>
<tr class="memdesc:a26c4c58db02fb60a08349360967532df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the GType for this class, for use with the underlying GObject type system.  <a href="#a26c4c58db02fb60a08349360967532df">More...</a><br /></td></tr>
<tr class="separator:a26c4c58db02fb60a08349360967532df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classGst_1_1Object"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classGst_1_1Object')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classGst_1_1Object.html">Gst::Object</a></td></tr>
<tr class="memitem:a8d7dfcf69a7c5c6086ab8149626fffcd inherit pub_static_methods_classGst_1_1Object"><td class="memItemLeft" align="right" valign="top">static GType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Object.html#a8d7dfcf69a7c5c6086ab8149626fffcd">get_type</a> ()</td></tr>
<tr class="memdesc:a8d7dfcf69a7c5c6086ab8149626fffcd inherit pub_static_methods_classGst_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the GType for this class, for use with the underlying GObject type system.  <a href="classGst_1_1Object.html#a8d7dfcf69a7c5c6086ab8149626fffcd">More...</a><br /></td></tr>
<tr class="separator:a8d7dfcf69a7c5c6086ab8149626fffcd inherit pub_static_methods_classGst_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a036969c9ee33ffe4270c2ceec02222a6 inherit pub_static_methods_classGst_1_1Object"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Object.html#a036969c9ee33ffe4270c2ceec02222a6">check_uniqueness</a> (const Glib::ListHandle&lt; const <a class="el" href="classGst_1_1Object.html">Gst::Object</a> &gt;&amp; list, const Glib::ustring&amp; name)</td></tr>
<tr class="memdesc:a036969c9ee33ffe4270c2ceec02222a6 inherit pub_static_methods_classGst_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if there is any object named <em>name</em> in <em>list</em>.  <a href="classGst_1_1Object.html#a036969c9ee33ffe4270c2ceec02222a6">More...</a><br /></td></tr>
<tr class="separator:a036969c9ee33ffe4270c2ceec02222a6 inherit pub_static_methods_classGst_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a29b97cd7fdacb477b88ded24c57f4323"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Element.html#a29b97cd7fdacb477b88ded24c57f4323">on_no_more_pads</a> ()</td></tr>
<tr class="memdesc:a29b97cd7fdacb477b88ded24c57f4323"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a default handler for the signal <a class="el" href="classGst_1_1Element.html#a419abecd2a358f6157ba82dbb2f1e067">signal_no_more_pads()</a>.  <a href="#a29b97cd7fdacb477b88ded24c57f4323">More...</a><br /></td></tr>
<tr class="separator:a29b97cd7fdacb477b88ded24c57f4323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e549a637bdd97fa4163fe89b0b79003"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Element.html#a6e549a637bdd97fa4163fe89b0b79003">on_pad_added</a> (const Glib::RefPtr&lt; <a class="el" href="classGst_1_1Pad.html">Gst::Pad</a> &gt;&amp; new_pad)</td></tr>
<tr class="memdesc:a6e549a637bdd97fa4163fe89b0b79003"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a default handler for the signal <a class="el" href="classGst_1_1Element.html#aaaf2d91e5aafe78141c3cf8c80724938">signal_pad_added()</a>.  <a href="#a6e549a637bdd97fa4163fe89b0b79003">More...</a><br /></td></tr>
<tr class="separator:a6e549a637bdd97fa4163fe89b0b79003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa846a7e69471cea3392518871c6b6d89"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Element.html#aa846a7e69471cea3392518871c6b6d89">on_pad_removed</a> (const Glib::RefPtr&lt; <a class="el" href="classGst_1_1Pad.html">Gst::Pad</a> &gt;&amp; old_pad)</td></tr>
<tr class="memdesc:aa846a7e69471cea3392518871c6b6d89"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a default handler for the signal <a class="el" href="classGst_1_1Element.html#a00f82141e3f402192b056fcb42aa24d4">signal_pad_removed()</a>.  <a href="#aa846a7e69471cea3392518871c6b6d89">More...</a><br /></td></tr>
<tr class="separator:aa846a7e69471cea3392518871c6b6d89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classGst_1_1Object"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classGst_1_1Object')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classGst_1_1Object.html">Gst::Object</a></td></tr>
<tr class="memitem:a133db3a4c137e5cc57227edb343d6fdb inherit pro_methods_classGst_1_1Object"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Object.html#a133db3a4c137e5cc57227edb343d6fdb">on_deep_notify</a> (const Glib::RefPtr&lt; <a class="el" href="classGst_1_1Object.html">Gst::Object</a> &gt;&amp; prop_object, GParamSpec* prop)</td></tr>
<tr class="memdesc:a133db3a4c137e5cc57227edb343d6fdb inherit pro_methods_classGst_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a default handler for the signal <a class="el" href="classGst_1_1Object.html#ac0fe96dbc1176a937bdb829ad3334afb">signal_deep_notify()</a>.  <a href="classGst_1_1Object.html#a133db3a4c137e5cc57227edb343d6fdb">More...</a><br /></td></tr>
<tr class="separator:a133db3a4c137e5cc57227edb343d6fdb inherit pro_methods_classGst_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a7128ca440b26df3c7807db690b03e572"><td class="memItemLeft" align="right" valign="top">Glib::RefPtr&lt; <a class="el" href="classGst_1_1Element.html">Gst::Element</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Element.html#a7128ca440b26df3c7807db690b03e572">wrap</a> (GstElement* object, bool take_copy=false)</td></tr>
<tr class="memdesc:a7128ca440b26df3c7807db690b03e572"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="namespaceGlib.html#a43fcab2a44083e8b7b6a1c8193acae2b">Glib::wrap()</a> method for this object.  <a href="#a7128ca440b26df3c7807db690b03e572">More...</a><br /></td></tr>
<tr class="separator:a7128ca440b26df3c7807db690b03e572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header related_classGst_1_1Object"><td colspan="2" onclick="javascript:toggleInherit('related_classGst_1_1Object')"><img src="closed.png" alt="-"/>&#160;Related Functions inherited from <a class="el" href="classGst_1_1Object.html">Gst::Object</a></td></tr>
<tr class="memitem:a78a831adab0d01760dd9cddec10f8986 inherit related_classGst_1_1Object"><td class="memItemLeft" align="right" valign="top">Glib::RefPtr&lt; <a class="el" href="classGst_1_1Object.html">Gst::Object</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGst_1_1Object.html#a78a831adab0d01760dd9cddec10f8986">wrap</a> (GstObject* object, bool take_copy=false)</td></tr>
<tr class="memdesc:a78a831adab0d01760dd9cddec10f8986 inherit related_classGst_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="namespaceGlib.html#a43fcab2a44083e8b7b6a1c8193acae2b">Glib::wrap()</a> method for this object.  <a href="classGst_1_1Object.html#a78a831adab0d01760dd9cddec10f8986">More...</a><br /></td></tr>
<tr class="separator:a78a831adab0d01760dd9cddec10f8986 inherit related_classGst_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Abstract base class for all pipeline elements. </p>
<p><a class="el" href="classGst_1_1Element.html" title="Abstract base class for all pipeline elements. ">Gst::Element</a> is the abstract base class needed to construct an element that can be used in a GStreamer pipeline. Please refer to the plugin writers guide for more information on creating <a class="el" href="classGst_1_1Element.html" title="Abstract base class for all pipeline elements. ">Gst::Element</a> subclasses.</p>
<p>The name of a <a class="el" href="classGst_1_1Element.html" title="Abstract base class for all pipeline elements. ">Gst::Element</a> can be get with <a class="el" href="classGst_1_1Object.html#ab8a7e72f2bf6539244668d7238d46159" title="Returns a copy of the name of object. ">get_name()</a> and set with <a class="el" href="classGst_1_1Object.html#a91745b6c35472bc28fde65c770444478" title="Sets the name of object, or gives object a guaranteed unique name (if name is nullptr). ">set_name()</a>.</p>
<p>Elements can have pads (of the type <a class="el" href="classGst_1_1Pad.html" title="A class that represents objects contained by elements that allows links to other elements. ">Gst::Pad</a>). These pads link to pads on other elements. <a class="el" href="classGst_1_1Buffer.html" title="Data-passing buffer type. ">Gst::Buffer</a> flow between these linked pads. A <a class="el" href="classGst_1_1Element.html" title="Abstract base class for all pipeline elements. ">Gst::Element</a> has a GList of <a class="el" href="classGst_1_1Pad.html" title="A class that represents objects contained by elements that allows links to other elements. ">Gst::Pad</a> structures for all their input (or sink) and output (or source) pads. Core and plug-in writers can add and remove pads with <a class="el" href="classGst_1_1Element.html#a6f20a79f8c4f5e8503efe4a2a81f6dcb" title="Adds a pad (link point) to element. ">add_pad()</a> and <a class="el" href="classGst_1_1Element.html#a61b542aafbb389d69da3033725521d6d" title="Removes pad from element. ">remove_pad()</a>.</p>
<p>An existing pad of an element can be retrieved by name with <a class="el" href="classGst_1_1Element.html#a71121475e7d509dfc1afb289ecb42dbc" title="Retrieves a pad from element by name. ">get_static_pad()</a>. A new dynamic pad can be created using <a class="el" href="classGst_1_1Element.html#ad082533664f013db0c3e629a00142464" title="Retrieves a request pad from the element according to the provided template. ">request_pad()</a> with a <a class="el" href="classGst_1_1PadTemplate.html" title="A class that describes the media type of a pad. ">Gst::PadTemplate</a>. An iterator of all pads can be retrieved with <a class="el" href="classGst_1_1Element.html#a490d9605ec092f544df55a54f823637f" title="Retrieves an iterator of element&#39;s pads. ">iterate_pads()</a>.</p>
<p>Elements can be linked through their pads. If the link is straightforward, use the <a class="el" href="classGst_1_1Element.html#ab41115df14a718d340380c2d719a6ae4" title="Links this source element to the dest element. ">link()</a> convenience function to link two elements. Use link_filtered() to link two elements constrained by a specified set of <a class="el" href="classGst_1_1Caps.html" title="Structure describing sets of media formats. ">Gst::Caps</a>. For finer control, use <a class="el" href="classGst_1_1Element.html#aea27df909b82a7dbcf15d21fe4a6ae17" title="Links the two named pads of the source and destination elements. ">link_pads()</a> and link_pads_filtered() to specify the pads to link on each element by name.</p>
<p>Each element has a state (see <a class="el" href="group__gstreamermmEnums.html#gabb043e1d41659fd842f10949f91e7a7f" title="The possible states an element can be in. ">Gst::State</a>). You can get and set the state of an element with <a class="el" href="classGst_1_1Element.html#a74b7e2811f2d7d4a5ae49e43eace975e" title="Gets the state of the element. ">get_state()</a> and <a class="el" href="classGst_1_1Element.html#a9f99dbf420c0f34005662dac54fb16b7" title="Sets the state of the element. ">set_state()</a>. Setting a state triggers a <a class="el" href="group__gstreamermmEnums.html#ga430f25337ed3cd75da2a088ce56bb3d5" title="These are the different state changes an element goes through. ">Gst::StateChange</a>. To get a string representation of a <a class="el" href="group__gstreamermmEnums.html#gabb043e1d41659fd842f10949f91e7a7f" title="The possible states an element can be in. ">Gst::State</a>, use <a class="el" href="namespaceGst_1_1Enums.html#a0378724782d11e29da8cfb6e708f66c9" title="Gets a string representing the given state. ">Gst::Enums::get_name()</a>.</p>
<p>You can get and set a <a class="el" href="classGst_1_1Clock.html" title="Abstract class for global clocks GStreamer uses a global clock to synchronize the plugins in a pipeli...">Gst::Clock</a> on an element using <a class="el" href="classGst_1_1Element.html#a9d2e1731488360438dac236fb198e2a0" title="Gets the currently configured clock of the element. ">get_clock()</a> and <a class="el" href="classGst_1_1Element.html#ad1a766827de41c955da267718c76db9a" title="Sets the clock for the element. ">set_clock()</a>. Some elements can provide a clock for the pipeline if the <a class="el" href="namespaceGst.html#gaf326d5b7f7963a4b2dbe8cc1121adc9ea4e832e5c5feb19f2782b7f6fd15d7870" title="The element can provide a clock. ">Gst::ELEMENT_FLAG_PROVIDE_CLOCK</a> flag is set. With the <a class="el" href="classGst_1_1Element.html#af7d7f25e4d79771efe256ff6c40ecbb5" title="Get the clock provided by the given element. ">provide_clock()</a> method one can retrieve the clock provided by such an element. Not all elements require a clock to operate correctly. If the <a class="el" href="namespaceGst.html#gaf326d5b7f7963a4b2dbe8cc1121adc9ea71b2f5b81e8e11efc1750ba5804011c2" title="The element requires a clock. ">Gst::ELEMENT_FLAG_REQUIRE_CLOCK</a> flag is set, a clock should be set on the element with <a class="el" href="classGst_1_1Element.html#ad1a766827de41c955da267718c76db9a" title="Sets the clock for the element. ">set_clock()</a>.</p>
<p>Note that clock selection and distribution is normally handled by the toplevel <a class="el" href="classGst_1_1Pipeline.html" title="A top-level bin with clocking and bus management functionality. ">Gst::Pipeline</a> so the clock functions are only to be used in very specific situations.</p>
<p>Last reviewed on 2016-05-18 (1.8.0). </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a68bf7407277bbe872ad6900643f581e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68bf7407277bbe872ad6900643f581e4">&#9670;&#160;</a></span>Element()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Gst::Element::Element </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGst_1_1Element.html">Element</a>&amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a54a2f9a1318f4dfeaaecfb590601011c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54a2f9a1318f4dfeaaecfb590601011c">&#9670;&#160;</a></span>~Element()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Gst::Element::~Element </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aaff02239da99117648e17079a9443166"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaff02239da99117648e17079a9443166">&#9670;&#160;</a></span>abort_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gst::Element::abort_state </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Abort the state change of the element. </p>
<p>This function is used by elements that do asynchronous state changes and find out something is wrong.</p>
<p>This function should be called with the STATE_LOCK held.</p>
<p>MT safe. </p>

</div>
</div>
<a id="a6f20a79f8c4f5e8503efe4a2a81f6dcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f20a79f8c4f5e8503efe4a2a81f6dcb">&#9670;&#160;</a></span>add_pad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gst::Element::add_pad </td>
          <td>(</td>
          <td class="paramtype">const Glib::RefPtr&lt; <a class="el" href="classGst_1_1Pad.html">Gst::Pad</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>pad</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a pad (link point) to <em>element</em>. </p>
<p><em>pad's</em> parent will be set to <em>element</em>; see <a class="el" href="classGst_1_1Object.html#a09a2f2fcfb0fabee2597b34a0b7c3fe4" title="Sets the parent of object to parent. ">Gst::Object::set_parent()</a> for refcounting information.</p>
<p>Pads are not automatically activated so elements should perform the needed steps to activate the pad in case this pad is added in the PAUSED or PLAYING state. See <a class="el" href="classGst_1_1Pad.html#ae4310bd528bc3eb83c237885133b811a" title="Activates or deactivates the given pad. ">Gst::Pad::set_active()</a> for more information about activating pads.</p>
<p>The pad and the element should be unlocked when calling this function.</p>
<p>This function will emit the <a class="el" href="classGst_1_1Element.html#aaaf2d91e5aafe78141c3cf8c80724938">Gst::Element::signal_pad_added()</a> signal on the element.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pad</td><td>The <a class="el" href="classGst_1_1Pad.html" title="A class that represents objects contained by elements that allows links to other elements. ">Gst::Pad</a> to add to the element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the pad could be added. This function can fail when a pad with the same name already existed or the pad already had another parent.</dd></dl>
<p>MT safe. </p>

</div>
</div>
<a id="ac014794d6dd75b9896d22682388c8581"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac014794d6dd75b9896d22682388c8581">&#9670;&#160;</a></span>change_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__gstreamermmEnums.html#gacaa5e30b631a84cf95a0f8918e96f025">StateChangeReturn</a> Gst::Element::change_state </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__gstreamermmEnums.html#ga430f25337ed3cd75da2a088ce56bb3d5">StateChange</a>&#160;</td>
          <td class="paramname"><em>transition</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform <em>transition</em> on <em>element</em>. </p>
<p>This function must be called with STATE_LOCK held and is mainly used internally.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transition</td><td>The requested transition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__gstreamermmEnums.html#gacaa5e30b631a84cf95a0f8918e96f025" title="The possible return values from a state change function such as Gst::Element::set_state(). ">Gst::StateChangeReturn</a> of the state transition. </dd></dl>

</div>
</div>
<a id="a1a0c04186513d05eb90fa71001639bc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a0c04186513d05eb90fa71001639bc7">&#9670;&#160;</a></span>change_state_vfunc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__gstreamermmEnums.html#gacaa5e30b631a84cf95a0f8918e96f025">StateChangeReturn</a> Gst::Element::change_state_vfunc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__gstreamermmEnums.html#ga430f25337ed3cd75da2a088ce56bb3d5">StateChange</a>&#160;</td>
          <td class="paramname"><em>transition</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called by set_state to perform an incremental state change. </p>

</div>
</div>
<a id="a8ad12d3eeb5b9842201675492cd19cb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ad12d3eeb5b9842201675492cd19cb4">&#9670;&#160;</a></span>continue_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__gstreamermmEnums.html#gacaa5e30b631a84cf95a0f8918e96f025">StateChangeReturn</a> Gst::Element::continue_state </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__gstreamermmEnums.html#gacaa5e30b631a84cf95a0f8918e96f025">StateChangeReturn</a>&#160;</td>
          <td class="paramname"><em>ret</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Commit the state change of the element and proceed to the next pending state if any. </p>
<p>This function is used by elements that do asynchronous state changes. The core will normally call this method automatically when an element returned <a class="el" href="namespaceGst.html#gacaa5e30b631a84cf95a0f8918e96f025aeeee00a453937b848aac52c8a58e3281" title="The state change succeeded. ">Gst::STATE_CHANGE_SUCCESS</a> from the state change function.</p>
<p>If after calling this method the element still has not reached the pending state, the next state change is performed.</p>
<p>This method is used internally and should normally not be called by plugins or applications.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ret</td><td>The previous state return value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the commit state change.</dd></dl>
<p>MT safe. </p>

</div>
</div>
<a id="abb7cdeb640b7bee61540db8f39baa13d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb7cdeb640b7bee61540db8f39baa13d">&#9670;&#160;</a></span>create_all_pads()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gst::Element::create_all_pads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pad for each pad template that is always available. </p>
<p>This function is only useful during object initialization of subclasses of <a class="el" href="classGst_1_1Element.html" title="Abstract base class for all pipeline elements. ">Gst::Element</a>. </p>

</div>
</div>
<a id="abd2707d6644b4713012e474050bbd9eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd2707d6644b4713012e474050bbd9eb">&#9670;&#160;</a></span>create_compatible_pad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::RefPtr&lt;<a class="el" href="classGst_1_1Pad.html">Gst::Pad</a>&gt; Gst::Element::create_compatible_pad </td>
          <td>(</td>
          <td class="paramtype">const Glib::RefPtr&lt; const <a class="el" href="classGst_1_1Pad.html">Gst::Pad</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>pad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Glib::RefPtr&lt; const <a class="el" href="classGst_1_1Caps.html">Gst::Caps</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>caps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Looks for an unlinked pad to which the given pad can link. </p>
<p>It is not guaranteed that linking the pads will work, though it should work in most cases.</p>
<p>This function will first attempt to find a compatible unlinked ALWAYS pad, and if none can be found, it will request a compatible REQUEST pad by looking at the templates of <em>element</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pad</td><td>The <a class="el" href="classGst_1_1Pad.html" title="A class that represents objects contained by elements that allows links to other elements. ">Gst::Pad</a> to find a compatible one for. </td></tr>
    <tr><td class="paramname">caps</td><td>The <a class="el" href="classGst_1_1Caps.html" title="Structure describing sets of media formats. ">Gst::Caps</a> to use as a filter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classGst_1_1Pad.html" title="A class that represents objects contained by elements that allows links to other elements. ">Gst::Pad</a> to which a link can be made, or <code>nullptr</code> if one cannot be found. Gst::Object::unref() after usage. </dd></dl>

</div>
</div>
<a id="abe5138d41072cfc8c3af1805d44b1e54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe5138d41072cfc8c3af1805d44b1e54">&#9670;&#160;</a></span>get_base_time()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">ClockTime</a> Gst::Element::get_base_time </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the base time of the element. </p>
<p>The base time is the absolute time of the clock when this element was last put to PLAYING. Subtracting the base time from the clock time gives the running time of the element.</p>
<dl class="section return"><dt>Returns</dt><dd>The base time of the element.</dd></dl>
<p>MT safe. </p>

</div>
</div>
<a id="a80d48bb2aaf211c177d51d7f250334b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80d48bb2aaf211c177d51d7f250334b7">&#9670;&#160;</a></span>get_bus() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::RefPtr&lt;<a class="el" href="classGst_1_1Bus.html">Gst::Bus</a>&gt; Gst::Element::get_bus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the bus of the element. </p>
<p>Note that only a <a class="el" href="classGst_1_1Pipeline.html" title="A top-level bin with clocking and bus management functionality. ">Gst::Pipeline</a> will provide a bus for the application.</p>
<dl class="section return"><dt>Returns</dt><dd>The element's <a class="el" href="classGst_1_1Bus.html" title="A class that encompasses the GStreamer asynchronous message bus subsystem. ">Gst::Bus</a>. unref after usage.</dd></dl>
<p>MT safe. </p>

</div>
</div>
<a id="aa6ea71674aa04e12781bded3abfe7354"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6ea71674aa04e12781bded3abfe7354">&#9670;&#160;</a></span>get_bus() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::RefPtr&lt;const <a class="el" href="classGst_1_1Bus.html">Gst::Bus</a>&gt; Gst::Element::get_bus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the bus of the element. </p>
<p>Note that only a <a class="el" href="classGst_1_1Pipeline.html" title="A top-level bin with clocking and bus management functionality. ">Gst::Pipeline</a> will provide a bus for the application.</p>
<dl class="section return"><dt>Returns</dt><dd>The element's <a class="el" href="classGst_1_1Bus.html" title="A class that encompasses the GStreamer asynchronous message bus subsystem. ">Gst::Bus</a>. unref after usage.</dd></dl>
<p>MT safe. </p>

</div>
</div>
<a id="a9d2e1731488360438dac236fb198e2a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d2e1731488360438dac236fb198e2a0">&#9670;&#160;</a></span>get_clock() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::RefPtr&lt;<a class="el" href="classGst_1_1Clock.html">Gst::Clock</a>&gt; Gst::Element::get_clock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the currently configured clock of the element. </p>
<p>This is the clock as was last set with <a class="el" href="classGst_1_1Element.html#ad1a766827de41c955da267718c76db9a" title="Sets the clock for the element. ">set_clock()</a>.</p>
<p>Elements in a pipeline will only have their clock set when the pipeline is in the PLAYING state.</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classGst_1_1Clock.html" title="Abstract class for global clocks GStreamer uses a global clock to synchronize the plugins in a pipeli...">Gst::Clock</a> of the element. unref after usage.</dd></dl>
<p>MT safe. </p>

</div>
</div>
<a id="a68bbad716c19226980e7189407c96740"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68bbad716c19226980e7189407c96740">&#9670;&#160;</a></span>get_clock() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::RefPtr&lt;const <a class="el" href="classGst_1_1Clock.html">Gst::Clock</a>&gt; Gst::Element::get_clock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the currently configured clock of the element. </p>
<p>This is the clock as was last set with <a class="el" href="classGst_1_1Element.html#ad1a766827de41c955da267718c76db9a" title="Sets the clock for the element. ">set_clock()</a>.</p>
<p>Elements in a pipeline will only have their clock set when the pipeline is in the PLAYING state.</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classGst_1_1Clock.html" title="Abstract class for global clocks GStreamer uses a global clock to synchronize the plugins in a pipeli...">Gst::Clock</a> of the element. unref after usage.</dd></dl>
<p>MT safe. </p>

</div>
</div>
<a id="a1e9331096e5f7f04c656ba8e7e09b77d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e9331096e5f7f04c656ba8e7e09b77d">&#9670;&#160;</a></span>get_compatible_pad_template() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::RefPtr&lt;<a class="el" href="classGst_1_1PadTemplate.html">Gst::PadTemplate</a>&gt; Gst::Element::get_compatible_pad_template </td>
          <td>(</td>
          <td class="paramtype">const Glib::RefPtr&lt; const <a class="el" href="classGst_1_1PadTemplate.html">Gst::PadTemplate</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>compattempl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves a pad template from <em>element</em> that is compatible with <em>compattempl</em>. </p>
<p>Pads from compatible templates can be linked together.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compattempl</td><td>The <a class="el" href="classGst_1_1PadTemplate.html" title="A class that describes the media type of a pad. ">Gst::PadTemplate</a> to find a compatible template for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A compatible <a class="el" href="classGst_1_1PadTemplate.html" title="A class that describes the media type of a pad. ">Gst::PadTemplate</a>, or <code>nullptr</code> if none was found. No unreferencing is necessary. </dd></dl>

</div>
</div>
<a id="a84168677c3acfe326e22e78fa9c7d09b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84168677c3acfe326e22e78fa9c7d09b">&#9670;&#160;</a></span>get_compatible_pad_template() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::RefPtr&lt;const <a class="el" href="classGst_1_1PadTemplate.html">Gst::PadTemplate</a>&gt; Gst::Element::get_compatible_pad_template </td>
          <td>(</td>
          <td class="paramtype">const Glib::RefPtr&lt; const <a class="el" href="classGst_1_1PadTemplate.html">Gst::PadTemplate</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>compattempl</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves a pad template from <em>element</em> that is compatible with <em>compattempl</em>. </p>
<p>Pads from compatible templates can be linked together.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compattempl</td><td>The <a class="el" href="classGst_1_1PadTemplate.html" title="A class that describes the media type of a pad. ">Gst::PadTemplate</a> to find a compatible template for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A compatible <a class="el" href="classGst_1_1PadTemplate.html" title="A class that describes the media type of a pad. ">Gst::PadTemplate</a>, or <code>nullptr</code> if none was found. No unreferencing is necessary. </dd></dl>

</div>
</div>
<a id="a30d67deee57effb0283c67a5a21986d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30d67deee57effb0283c67a5a21986d2">&#9670;&#160;</a></span>get_context()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::RefPtr&lt;<a class="el" href="classGst_1_1Context.html">Gst::Context</a>&gt; Gst::Element::get_context </td>
          <td>(</td>
          <td class="paramtype">const Glib::ustring &amp;&#160;</td>
          <td class="paramname"><em>context_type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the context with <em>context_type</em> set on the element or <code>nullptr</code>. </p>
<p>MT safe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context_type</td><td>A name of a context to retrieve. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classGst_1_1Context.html" title="Lightweight objects to represent element contexts. ">Gst::Context</a> or <code>nullptr</code>. </dd></dl>

</div>
</div>
<a id="a7572aa87101ac491c1c80e70c6cb5cb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7572aa87101ac491c1c80e70c6cb5cb5">&#9670;&#160;</a></span>get_context_unlocked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::RefPtr&lt;<a class="el" href="classGst_1_1Context.html">Gst::Context</a>&gt; Gst::Element::get_context_unlocked </td>
          <td>(</td>
          <td class="paramtype">const Glib::ustring &amp;&#160;</td>
          <td class="paramname"><em>context_type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the context with <em>context_type</em> set on the element or <code>nullptr</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context_type</td><td>A name of a context to retrieve. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classGst_1_1Context.html" title="Lightweight objects to represent element contexts. ">Gst::Context</a> or <code>nullptr</code>. </dd></dl>

</div>
</div>
<a id="a563570e8ba23c4938accf87cff9b2c47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a563570e8ba23c4938accf87cff9b2c47">&#9670;&#160;</a></span>get_contexts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00965.html">std::vector</a>&lt; Glib::RefPtr&lt;<a class="el" href="classGst_1_1Context.html">Gst::Context</a>&gt; &gt; Gst::Element::get_contexts </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the contexts set on the element. </p>
<p>MT safe.</p>
<dl class="section return"><dt>Returns</dt><dd>List of <a class="el" href="classGst_1_1Context.html" title="Lightweight objects to represent element contexts. ">Gst::Context</a>. </dd></dl>

</div>
</div>
<a id="ad07256e0790d6781fc6c37c03a2e2d90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad07256e0790d6781fc6c37c03a2e2d90">&#9670;&#160;</a></span>get_factory() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::RefPtr&lt;<a class="el" href="classGst_1_1ElementFactory.html">Gst::ElementFactory</a>&gt; Gst::Element::get_factory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the factory that was used to create this element. </p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classGst_1_1ElementFactory.html" title="Create Gst::Element &#39;s from a factory. ">Gst::ElementFactory</a> used for creating this element. no refcounting is needed. </dd></dl>

</div>
</div>
<a id="a424089fb124677c5d5c28721fcdfc1c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a424089fb124677c5d5c28721fcdfc1c4">&#9670;&#160;</a></span>get_factory() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::RefPtr&lt;const <a class="el" href="classGst_1_1ElementFactory.html">Gst::ElementFactory</a>&gt; Gst::Element::get_factory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the factory that was used to create this element. </p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classGst_1_1ElementFactory.html" title="Create Gst::Element &#39;s from a factory. ">Gst::ElementFactory</a> used for creating this element. no refcounting is needed. </dd></dl>

</div>
</div>
<a id="a58917308a93eb2029f850c34510e3ff3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58917308a93eb2029f850c34510e3ff3">&#9670;&#160;</a></span>get_pad_template()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::RefPtr&lt;<a class="el" href="classGst_1_1PadTemplate.html">Gst::PadTemplate</a>&gt; Gst::Element::get_pad_template </td>
          <td>(</td>
          <td class="paramtype">const Glib::ustring &amp;&#160;</td>
          <td class="paramname"><em>factory_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aea8e7821ecf7acdd24bb08b0e638caa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea8e7821ecf7acdd24bb08b0e638caa7">&#9670;&#160;</a></span>get_request_pad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::RefPtr&lt;<a class="el" href="classGst_1_1Pad.html">Gst::Pad</a>&gt; Gst::Element::get_request_pad </td>
          <td>(</td>
          <td class="paramtype">const Glib::ustring &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves a pad from the element by name (e.g. "src_\\%d"). </p>
<p>This version only retrieves request pads. The pad should be released with <a class="el" href="classGst_1_1Element.html#aa614a038b969d37f5db69999e6200c7a" title="Makes the element free the previously requested pad as obtained with get_request_pad(). ">release_request_pad()</a>.</p>
<p>This method is slower than manually getting the pad template and calling <a class="el" href="classGst_1_1Element.html#ad082533664f013db0c3e629a00142464" title="Retrieves a request pad from the element according to the provided template. ">request_pad()</a> if the pads should have a specific name (e.g. <em>name</em> is "src_1" instead of "src_\\%u").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the request <a class="el" href="classGst_1_1Pad.html" title="A class that represents objects contained by elements that allows links to other elements. ">Gst::Pad</a> to retrieve. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Requested <a class="el" href="classGst_1_1Pad.html" title="A class that represents objects contained by elements that allows links to other elements. ">Gst::Pad</a> if found, otherwise <code>nullptr</code>. Release after usage. </dd></dl>

</div>
</div>
<a id="a015311b1871fa70ed8edb6a98fbd423d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a015311b1871fa70ed8edb6a98fbd423d">&#9670;&#160;</a></span>get_start_time()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a> Gst::Element::get_start_time </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the start time of the element. </p>
<p>The start time is the running time of the clock when this element was last put to PAUSED.</p>
<p>Usually the start_time is managed by a toplevel element such as <a class="el" href="classGst_1_1Pipeline.html" title="A top-level bin with clocking and bus management functionality. ">Gst::Pipeline</a>.</p>
<p>MT safe.</p>
<dl class="section return"><dt>Returns</dt><dd>The start time of the element. </dd></dl>

</div>
</div>
<a id="a74b7e2811f2d7d4a5ae49e43eace975e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74b7e2811f2d7d4a5ae49e43eace975e">&#9670;&#160;</a></span>get_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__gstreamermmEnums.html#gacaa5e30b631a84cf95a0f8918e96f025">StateChangeReturn</a> Gst::Element::get_state </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__gstreamermmEnums.html#gabb043e1d41659fd842f10949f91e7a7f">State</a>&amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__gstreamermmEnums.html#gabb043e1d41659fd842f10949f91e7a7f">State</a>&amp;&#160;</td>
          <td class="paramname"><em>pending</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">ClockTime</a>&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the state of the element. </p>
<p>For elements that performed an ASYNC state change, as reported by <a class="el" href="classGst_1_1Element.html#a9f99dbf420c0f34005662dac54fb16b7" title="Sets the state of the element. ">set_state()</a>, this function will block up to the specified timeout value for the state change to complete. If the element completes the state change or goes into an error, this function returns immediately with a return value of <a class="el" href="namespaceGst.html#gacaa5e30b631a84cf95a0f8918e96f025aeeee00a453937b848aac52c8a58e3281" title="The state change succeeded. ">Gst::STATE_CHANGE_SUCCESS</a> or <a class="el" href="namespaceGst.html#gacaa5e30b631a84cf95a0f8918e96f025a993fcd0f933a3becee44c78b36fd2b4b" title="The state change failed. ">Gst::STATE_CHANGE_FAILURE</a> respectively.</p>
<p>For elements that did not return <a class="el" href="namespaceGst.html#gacaa5e30b631a84cf95a0f8918e96f025a77e50c46cf3919c152686b71cd419c3a" title="The state change will happen asynchronously. ">Gst::STATE_CHANGE_ASYNC</a>, this function returns the current and pending state immediately.</p>
<p>This function returns <a class="el" href="namespaceGst.html#gacaa5e30b631a84cf95a0f8918e96f025a954686a18685dd44685a2ddd5e66f15b" title="The state change succeeded but the element cannot produce data in Gst::STATE_PAUSED. ">Gst::STATE_CHANGE_NO_PREROLL</a> if the element successfully changed its state but is not able to provide data yet. This mostly happens for live sources that only produce data in <a class="el" href="namespaceGst.html#gabb043e1d41659fd842f10949f91e7a7fa396ac09161e15f45f8dc574a91bfef2b" title="The element is PLAYING, the Gst::Clock is running and the data is flowing. ">Gst::STATE_PLAYING</a>. While the state change return is equivalent to <a class="el" href="namespaceGst.html#gacaa5e30b631a84cf95a0f8918e96f025aeeee00a453937b848aac52c8a58e3281" title="The state change succeeded. ">Gst::STATE_CHANGE_SUCCESS</a>, it is returned to the application to signal that some sink elements might not be able to complete their state change because an element is not producing data to complete the preroll. When setting the element to playing, the preroll will complete and playback will start.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>A pointer to <a class="el" href="group__gstreamermmEnums.html#gabb043e1d41659fd842f10949f91e7a7f" title="The possible states an element can be in. ">Gst::State</a> to hold the state. Can be <code>nullptr</code>. </td></tr>
    <tr><td class="paramname">pending</td><td>A pointer to <a class="el" href="group__gstreamermmEnums.html#gabb043e1d41659fd842f10949f91e7a7f" title="The possible states an element can be in. ">Gst::State</a> to hold the pending state. Can be <code>nullptr</code>. </td></tr>
    <tr><td class="paramname">timeout</td><td>A <a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda" title="A data type to hold a time, measured in nanoseconds. ">Gst::ClockTime</a> to specify the timeout for an async state change or <a class="el" href="namespaceGst.html#a07ca62fa6d891070ab6d46c45cd388f1" title="A constant to define an undefined clock time. ">Gst::CLOCK_TIME_NONE</a> for infinite timeout. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespaceGst.html#gacaa5e30b631a84cf95a0f8918e96f025aeeee00a453937b848aac52c8a58e3281" title="The state change succeeded. ">Gst::STATE_CHANGE_SUCCESS</a> if the element has no more pending state and the last state change succeeded, <a class="el" href="namespaceGst.html#gacaa5e30b631a84cf95a0f8918e96f025a77e50c46cf3919c152686b71cd419c3a" title="The state change will happen asynchronously. ">Gst::STATE_CHANGE_ASYNC</a> if the element is still performing a state change or <a class="el" href="namespaceGst.html#gacaa5e30b631a84cf95a0f8918e96f025a993fcd0f933a3becee44c78b36fd2b4b" title="The state change failed. ">Gst::STATE_CHANGE_FAILURE</a> if the last state change failed.</dd></dl>
<p>MT safe. </p>

</div>
</div>
<a id="a7c9be14c0792eae794d650ca486dfbe6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c9be14c0792eae794d650ca486dfbe6">&#9670;&#160;</a></span>get_state_vfunc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__gstreamermmEnums.html#gacaa5e30b631a84cf95a0f8918e96f025">StateChangeReturn</a> Gst::Element::get_state_vfunc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__gstreamermmEnums.html#gabb043e1d41659fd842f10949f91e7a7f">State</a>&amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__gstreamermmEnums.html#gabb043e1d41659fd842f10949f91e7a7f">State</a>&amp;&#160;</td>
          <td class="paramname"><em>pending</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">ClockTime</a>&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the state of the element. </p>

</div>
</div>
<a id="a71121475e7d509dfc1afb289ecb42dbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71121475e7d509dfc1afb289ecb42dbc">&#9670;&#160;</a></span>get_static_pad() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::RefPtr&lt;<a class="el" href="classGst_1_1Pad.html">Gst::Pad</a>&gt; Gst::Element::get_static_pad </td>
          <td>(</td>
          <td class="paramtype">const Glib::ustring &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves a pad from <em>element</em> by name. </p>
<p>This version only retrieves already-existing (i.e. 'static') pads.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the static <a class="el" href="classGst_1_1Pad.html" title="A class that represents objects contained by elements that allows links to other elements. ">Gst::Pad</a> to retrieve. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The requested <a class="el" href="classGst_1_1Pad.html" title="A class that represents objects contained by elements that allows links to other elements. ">Gst::Pad</a> if found, otherwise <code>nullptr</code>. unref after usage.</dd></dl>
<p>MT safe. </p>

</div>
</div>
<a id="afc250ffcde9c807734449702d2ab4c56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc250ffcde9c807734449702d2ab4c56">&#9670;&#160;</a></span>get_static_pad() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::RefPtr&lt;const <a class="el" href="classGst_1_1Pad.html">Gst::Pad</a>&gt; Gst::Element::get_static_pad </td>
          <td>(</td>
          <td class="paramtype">const Glib::ustring &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves a pad from <em>element</em> by name. </p>
<p>This version only retrieves already-existing (i.e. 'static') pads.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the static <a class="el" href="classGst_1_1Pad.html" title="A class that represents objects contained by elements that allows links to other elements. ">Gst::Pad</a> to retrieve. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The requested <a class="el" href="classGst_1_1Pad.html" title="A class that represents objects contained by elements that allows links to other elements. ">Gst::Pad</a> if found, otherwise <code>nullptr</code>. unref after usage.</dd></dl>
<p>MT safe. </p>

</div>
</div>
<a id="a26c4c58db02fb60a08349360967532df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26c4c58db02fb60a08349360967532df">&#9670;&#160;</a></span>get_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static GType Gst::Element::get_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the GType for this class, for use with the underlying GObject type system. </p>

</div>
</div>
<a id="a7385513759359ebfb349b824ab463dbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7385513759359ebfb349b824ab463dbc">&#9670;&#160;</a></span>gobj() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GstElement* Gst::Element::gobj </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides access to the underlying C GObject. </p>

</div>
</div>
<a id="a7fa5fccfc067ed5d651f13e20ca052f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fa5fccfc067ed5d651f13e20ca052f2">&#9670;&#160;</a></span>gobj() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const GstElement* Gst::Element::gobj </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides access to the underlying C GObject. </p>

</div>
</div>
<a id="aaf406873b4b57582deff89ed621fb297"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf406873b4b57582deff89ed621fb297">&#9670;&#160;</a></span>gobj_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GstElement* Gst::Element::gobj_copy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides access to the underlying C instance. The caller is responsible for unrefing it. Use when directly setting fields in structs. </p>

</div>
</div>
<a id="a405e45fee201dee89ceb09a053bcc9e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a405e45fee201dee89ceb09a053bcc9e7">&#9670;&#160;</a></span>is_locked_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gst::Element::is_locked_state </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the state of an element is locked. </p>
<p>If the state of an element is locked, state changes of the parent don't affect the element. This way you can leave currently unused elements inside bins. Just lock their state before changing the state from <a class="el" href="namespaceGst.html#gabb043e1d41659fd842f10949f91e7a7fa07cf1506b030700024ecf1654c3796c2" title="The nullptr state or initial state of an element. ">Gst::STATE_NULL</a>.</p>
<p>MT safe.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code>, if the element's state is locked. </dd></dl>

</div>
</div>
<a id="a490d9605ec092f544df55a54f823637f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a490d9605ec092f544df55a54f823637f">&#9670;&#160;</a></span>iterate_pads() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGst_1_1Iterator.html">Gst::Iterator</a>&lt;<a class="el" href="classGst_1_1Pad.html">Gst::Pad</a>&gt; Gst::Element::iterate_pads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves an iterator of <em>element's</em> pads. </p>
<p>The iterator should be freed after usage. Also more specialized iterators exists such as <a class="el" href="classGst_1_1Element.html#aadadabfccf8ec2ce71da3c8156ef9caf" title="Retrieves an iterator of element&#39;s source pads. ">iterate_src_pads()</a> or <a class="el" href="classGst_1_1Element.html#a06d06d2217a48a8b136c62ae710681ba" title="Retrieves an iterator of element&#39;s sink pads. ">iterate_sink_pads()</a>.</p>
<p>The order of pads returned by the iterator will be the order in which the pads were added to the element.</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classGst_1_1Iterator.html" title="A class used to retrieve multiple reference counted elements in a thread safe way. ">Gst::Iterator</a> of <a class="el" href="classGst_1_1Pad.html" title="A class that represents objects contained by elements that allows links to other elements. ">Gst::Pad</a>.</dd></dl>
<p>MT safe. </p>

</div>
</div>
<a id="a27893ca54e7f043d420f69a50d1d26ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27893ca54e7f043d420f69a50d1d26ed">&#9670;&#160;</a></span>iterate_pads() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGst_1_1Iterator.html">Gst::Iterator</a>&lt;const <a class="el" href="classGst_1_1Pad.html">Gst::Pad</a>&gt; Gst::Element::iterate_pads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves an iterator of <em>element's</em> pads. </p>
<p>The iterator should be freed after usage. Also more specialized iterators exists such as <a class="el" href="classGst_1_1Element.html#aadadabfccf8ec2ce71da3c8156ef9caf" title="Retrieves an iterator of element&#39;s source pads. ">iterate_src_pads()</a> or <a class="el" href="classGst_1_1Element.html#a06d06d2217a48a8b136c62ae710681ba" title="Retrieves an iterator of element&#39;s sink pads. ">iterate_sink_pads()</a>.</p>
<p>The order of pads returned by the iterator will be the order in which the pads were added to the element.</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classGst_1_1Iterator.html" title="A class used to retrieve multiple reference counted elements in a thread safe way. ">Gst::Iterator</a> of <a class="el" href="classGst_1_1Pad.html" title="A class that represents objects contained by elements that allows links to other elements. ">Gst::Pad</a>.</dd></dl>
<p>MT safe. </p>

</div>
</div>
<a id="a06d06d2217a48a8b136c62ae710681ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06d06d2217a48a8b136c62ae710681ba">&#9670;&#160;</a></span>iterate_sink_pads() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGst_1_1Iterator.html">Gst::Iterator</a>&lt;<a class="el" href="classGst_1_1Pad.html">Gst::Pad</a>&gt; Gst::Element::iterate_sink_pads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves an iterator of <em>element's</em> sink pads. </p>
<p>The order of pads returned by the iterator will be the order in which the pads were added to the element.</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classGst_1_1Iterator.html" title="A class used to retrieve multiple reference counted elements in a thread safe way. ">Gst::Iterator</a> of <a class="el" href="classGst_1_1Pad.html" title="A class that represents objects contained by elements that allows links to other elements. ">Gst::Pad</a>.</dd></dl>
<p>MT safe. </p>

</div>
</div>
<a id="a695c0edf63f81b41399b8112cc2212c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a695c0edf63f81b41399b8112cc2212c4">&#9670;&#160;</a></span>iterate_sink_pads() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGst_1_1Iterator.html">Gst::Iterator</a>&lt;const <a class="el" href="classGst_1_1Pad.html">Gst::Pad</a>&gt; Gst::Element::iterate_sink_pads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves an iterator of <em>element's</em> sink pads. </p>
<p>The order of pads returned by the iterator will be the order in which the pads were added to the element.</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classGst_1_1Iterator.html" title="A class used to retrieve multiple reference counted elements in a thread safe way. ">Gst::Iterator</a> of <a class="el" href="classGst_1_1Pad.html" title="A class that represents objects contained by elements that allows links to other elements. ">Gst::Pad</a>.</dd></dl>
<p>MT safe. </p>

</div>
</div>
<a id="aadadabfccf8ec2ce71da3c8156ef9caf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadadabfccf8ec2ce71da3c8156ef9caf">&#9670;&#160;</a></span>iterate_src_pads() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGst_1_1Iterator.html">Gst::Iterator</a>&lt;<a class="el" href="classGst_1_1Pad.html">Gst::Pad</a>&gt; Gst::Element::iterate_src_pads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves an iterator of <em>element's</em> source pads. </p>
<p>The order of pads returned by the iterator will be the order in which the pads were added to the element.</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classGst_1_1Iterator.html" title="A class used to retrieve multiple reference counted elements in a thread safe way. ">Gst::Iterator</a> of <a class="el" href="classGst_1_1Pad.html" title="A class that represents objects contained by elements that allows links to other elements. ">Gst::Pad</a>.</dd></dl>
<p>MT safe. </p>

</div>
</div>
<a id="a7987f54c0196073393da4b4d411a330f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7987f54c0196073393da4b4d411a330f">&#9670;&#160;</a></span>iterate_src_pads() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGst_1_1Iterator.html">Gst::Iterator</a>&lt;const <a class="el" href="classGst_1_1Pad.html">Gst::Pad</a>&gt; Gst::Element::iterate_src_pads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves an iterator of <em>element's</em> source pads. </p>
<p>The order of pads returned by the iterator will be the order in which the pads were added to the element.</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classGst_1_1Iterator.html" title="A class used to retrieve multiple reference counted elements in a thread safe way. ">Gst::Iterator</a> of <a class="el" href="classGst_1_1Pad.html" title="A class that represents objects contained by elements that allows links to other elements. ">Gst::Pad</a>.</dd></dl>
<p>MT safe. </p>

</div>
</div>
<a id="ab41115df14a718d340380c2d719a6ae4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab41115df14a718d340380c2d719a6ae4">&#9670;&#160;</a></span>link() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::RefPtr&lt;<a class="el" href="classGst_1_1Element.html">Gst::Element</a>&gt; Gst::Element::link </td>
          <td>(</td>
          <td class="paramtype">const Glib::RefPtr&lt; <a class="el" href="classGst_1_1Element.html">Gst::Element</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>dest</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Links this source element to the <em>dest</em> element. </p>
<p>The link must be from source to destination - the other direction will not be tried. The function looks for existing pads that aren't linked yet. It will request new pads if necessary. Such pads need to be released manually when unlinking. If multiple links are possible, only one is established.</p>
<p>Make sure you have added your elements to a bin or pipeline with <a class="el" href="classGst_1_1Bin.html#a70138b916b8cfbbcef9c2b6c5be03066" title="Adds the given element to the bin. ">Gst::Bin::add()</a> before trying to link them.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>the <a class="el" href="classGst_1_1Element.html" title="Abstract base class for all pipeline elements. ">Gst::Element</a> containing the destination pad. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the destination element for further linking if desired. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00912.html">std::runtime_error</a></td><td>If the elements could not be linked. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8c7bfc955d8d0152e1af39d6bf0ab6ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c7bfc955d8d0152e1af39d6bf0ab6ed">&#9670;&#160;</a></span>link() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::RefPtr&lt;<a class="el" href="classGst_1_1Element.html">Gst::Element</a>&gt; Gst::Element::link </td>
          <td>(</td>
          <td class="paramtype">const Glib::RefPtr&lt; <a class="el" href="classGst_1_1Element.html">Gst::Element</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Glib::RefPtr&lt; <a class="el" href="classGst_1_1Caps.html">Gst::Caps</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Links <em>src</em> to <em>dest</em> using the given caps as filtercaps. </p>
<p>The link must be from source to destination; the other direction will not be tried. The function looks for existing pads that aren't linked yet. It will request new pads if necessary. If multiple links are possible, only one is established.</p>
<p>Make sure you have added your elements to a bin or pipeline with <a class="el" href="classGst_1_1Bin.html#a70138b916b8cfbbcef9c2b6c5be03066" title="Adds the given element to the bin. ">Gst::Bin::add()</a> before trying to link them.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The <a class="el" href="classGst_1_1Element.html" title="Abstract base class for all pipeline elements. ">Gst::Element</a> containing the destination pad. </td></tr>
    <tr><td class="paramname">filter</td><td>The <a class="el" href="classGst_1_1Caps.html" title="Structure describing sets of media formats. ">Gst::Caps</a> to filter the link. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the destination element for further linking if desired. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00912.html">std::runtime_error</a></td><td>If the elements could not be linked. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aea27df909b82a7dbcf15d21fe4a6ae17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea27df909b82a7dbcf15d21fe4a6ae17">&#9670;&#160;</a></span>link_pads() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gst::Element::link_pads </td>
          <td>(</td>
          <td class="paramtype">const Glib::ustring &amp;&#160;</td>
          <td class="paramname"><em>srcpadname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Glib::RefPtr&lt; <a class="el" href="classGst_1_1Element.html">Gst::Element</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Glib::ustring &amp;&#160;</td>
          <td class="paramname"><em>destpadname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Links the two named pads of the source and destination elements. </p>
<p>Side effect is that if one of the pads has no parent, it becomes a child of the parent of the other element. If they have different parents, the link fails.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">srcpadname</td><td>The name of the <a class="el" href="classGst_1_1Pad.html" title="A class that represents objects contained by elements that allows links to other elements. ">Gst::Pad</a> in source element or <code>nullptr</code> for any pad. </td></tr>
    <tr><td class="paramname">dest</td><td>The <a class="el" href="classGst_1_1Element.html" title="Abstract base class for all pipeline elements. ">Gst::Element</a> containing the destination pad. </td></tr>
    <tr><td class="paramname">destpadname</td><td>The name of the <a class="el" href="classGst_1_1Pad.html" title="A class that represents objects contained by elements that allows links to other elements. ">Gst::Pad</a> in destination element, or <code>nullptr</code> for any pad. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the pads could be linked, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a4262d8dcba6c3b5ec95555fd1464902c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4262d8dcba6c3b5ec95555fd1464902c">&#9670;&#160;</a></span>link_pads() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gst::Element::link_pads </td>
          <td>(</td>
          <td class="paramtype">const Glib::ustring &amp;&#160;</td>
          <td class="paramname"><em>srcpadname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Glib::RefPtr&lt; <a class="el" href="classGst_1_1Element.html">Gst::Element</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Glib::ustring &amp;&#160;</td>
          <td class="paramname"><em>destpadname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Glib::RefPtr&lt; <a class="el" href="classGst_1_1Caps.html">Gst::Caps</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Links the two named pads of the source and destination elements. </p>
<p>Side effect is that if one of the pads has no parent, it becomes a child of the parent of the other element. If they have different parents, the link fails. If <em>caps</em> is not <code>nullptr</code>, makes sure that the caps of the link is a subset of <em>caps</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">srcpadname</td><td>The name of the <a class="el" href="classGst_1_1Pad.html" title="A class that represents objects contained by elements that allows links to other elements. ">Gst::Pad</a> in source element or <code>nullptr</code> for any pad. </td></tr>
    <tr><td class="paramname">dest</td><td>The <a class="el" href="classGst_1_1Element.html" title="Abstract base class for all pipeline elements. ">Gst::Element</a> containing the destination pad. </td></tr>
    <tr><td class="paramname">destpadname</td><td>The name of the <a class="el" href="classGst_1_1Pad.html" title="A class that represents objects contained by elements that allows links to other elements. ">Gst::Pad</a> in destination element or <code>nullptr</code> for any pad. </td></tr>
    <tr><td class="paramname">filter</td><td>The <a class="el" href="classGst_1_1Caps.html" title="Structure describing sets of media formats. ">Gst::Caps</a> to filter the link, or <code>nullptr</code> for no filter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the pads could be linked, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ac94167114b235db33bfc8b1b4ce638b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac94167114b235db33bfc8b1b4ce638b8">&#9670;&#160;</a></span>link_pads() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gst::Element::link_pads </td>
          <td>(</td>
          <td class="paramtype">const Glib::ustring &amp;&#160;</td>
          <td class="paramname"><em>srcpadname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Glib::RefPtr&lt; <a class="el" href="classGst_1_1Element.html">Gst::Element</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Glib::ustring &amp;&#160;</td>
          <td class="paramname"><em>destpadname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__gstreamermmEnums.html#ga75cf82fd50d8978c04ce1a111ca9015f">PadLinkCheck</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Links the two named pads of the source and destination elements. </p>
<p>Side effect is that if one of the pads has no parent, it becomes a child of the parent of the other element. If they have different parents, the link fails.</p>
<p>Calling link_pads_full() with <em>flags</em> == <a class="el" href="namespaceGst.html#ga75cf82fd50d8978c04ce1a111ca9015fa6df00fb6181238c2cecac3000a1489b5" title="The default checks done when linking pads (i.e. ">Gst::PAD_LINK_CHECK_DEFAULT</a> is the same as calling <a class="el" href="classGst_1_1Element.html#aea27df909b82a7dbcf15d21fe4a6ae17" title="Links the two named pads of the source and destination elements. ">link_pads()</a> and the recommended way of linking pads with safety checks applied.</p>
<p>This is a convenience function for Gst::Pad::link_full().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">srcpadname</td><td>The name of the <a class="el" href="classGst_1_1Pad.html" title="A class that represents objects contained by elements that allows links to other elements. ">Gst::Pad</a> in source element or <code>nullptr</code> for any pad. </td></tr>
    <tr><td class="paramname">dest</td><td>The <a class="el" href="classGst_1_1Element.html" title="Abstract base class for all pipeline elements. ">Gst::Element</a> containing the destination pad. </td></tr>
    <tr><td class="paramname">destpadname</td><td>The name of the <a class="el" href="classGst_1_1Pad.html" title="A class that represents objects contained by elements that allows links to other elements. ">Gst::Pad</a> in destination element, or <code>nullptr</code> for any pad. </td></tr>
    <tr><td class="paramname">flags</td><td>The <a class="el" href="group__gstreamermmEnums.html#ga75cf82fd50d8978c04ce1a111ca9015f" title="The amount of checking to be done when linking pads. ">Gst::PadLinkCheck</a> to be performed when linking pads. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the pads could be linked, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a4ffbed46992421084ca770c1229c4ba4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ffbed46992421084ca770c1229c4ba4">&#9670;&#160;</a></span>lost_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gst::Element::lost_state </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Brings the element to the lost state. </p>
<p>The current state of the element is copied to the pending state so that any call to <a class="el" href="classGst_1_1Element.html#a74b7e2811f2d7d4a5ae49e43eace975e" title="Gets the state of the element. ">get_state()</a> will return <a class="el" href="namespaceGst.html#gacaa5e30b631a84cf95a0f8918e96f025a77e50c46cf3919c152686b71cd419c3a" title="The state change will happen asynchronously. ">Gst::STATE_CHANGE_ASYNC</a>.</p>
<p>An ASYNC_START message is posted. If the element was PLAYING, it will go to PAUSED. The element will be restored to its PLAYING state by the parent pipeline when it prerolls again.</p>
<p>This is mostly used for elements that lost their preroll buffer in the <a class="el" href="namespaceGst.html#gabb043e1d41659fd842f10949f91e7a7fa702f01b465f78938c8d8467a6c6892d3" title="The element is PAUSED, it is ready to accept and process data. ">Gst::STATE_PAUSED</a> or <a class="el" href="namespaceGst.html#gabb043e1d41659fd842f10949f91e7a7fa396ac09161e15f45f8dc574a91bfef2b" title="The element is PLAYING, the Gst::Clock is running and the data is flowing. ">Gst::STATE_PLAYING</a> state after a flush, they will go to their pending state again when a new preroll buffer is queued. This function can only be called when the element is currently not in error or an async state change.</p>
<p>This function is used internally and should normally not be called from plugins or applications. </p>

</div>
</div>
<a id="ab2d2718fe5d4f400d91002edf683e8b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2d2718fe5d4f400d91002edf683e8b2">&#9670;&#160;</a></span>no_more_pads()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gst::Element::no_more_pads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use this function to signal that the element does not expect any more pads to show up in the current pipeline. </p>
<p>This function should be called whenever pads have been added by the element itself. Elements with <a class="el" href="namespaceGst.html#gaab7edc44a9e16b5225d727442846bca0afbf82c110b0d2387bfdc3fb0fe8ca70e" title="The pad will become available depending on the media stream. ">Gst::PAD_SOMETIMES</a> pad templates use this in combination with autopluggers to figure out that the element is done initializing its pads.</p>
<p>This function emits the <a class="el" href="classGst_1_1Element.html#a419abecd2a358f6157ba82dbb2f1e067">Gst::Element::signal_no_more_pads()</a> signal.</p>
<p>MT safe. </p>

</div>
</div>
<a id="a29b97cd7fdacb477b88ded24c57f4323"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29b97cd7fdacb477b88ded24c57f4323">&#9670;&#160;</a></span>on_no_more_pads()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Gst::Element::on_no_more_pads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is a default handler for the signal <a class="el" href="classGst_1_1Element.html#a419abecd2a358f6157ba82dbb2f1e067">signal_no_more_pads()</a>. </p>

</div>
</div>
<a id="a6e549a637bdd97fa4163fe89b0b79003"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e549a637bdd97fa4163fe89b0b79003">&#9670;&#160;</a></span>on_pad_added()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Gst::Element::on_pad_added </td>
          <td>(</td>
          <td class="paramtype">const Glib::RefPtr&lt; <a class="el" href="classGst_1_1Pad.html">Gst::Pad</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>new_pad</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is a default handler for the signal <a class="el" href="classGst_1_1Element.html#aaaf2d91e5aafe78141c3cf8c80724938">signal_pad_added()</a>. </p>

</div>
</div>
<a id="aa846a7e69471cea3392518871c6b6d89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa846a7e69471cea3392518871c6b6d89">&#9670;&#160;</a></span>on_pad_removed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Gst::Element::on_pad_removed </td>
          <td>(</td>
          <td class="paramtype">const Glib::RefPtr&lt; <a class="el" href="classGst_1_1Pad.html">Gst::Pad</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>old_pad</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is a default handler for the signal <a class="el" href="classGst_1_1Element.html#a00f82141e3f402192b056fcb42aa24d4">signal_pad_removed()</a>. </p>

</div>
</div>
<a id="a4f6d05c3719a775b527186f1b0dad35d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f6d05c3719a775b527186f1b0dad35d">&#9670;&#160;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGst_1_1Element.html">Element</a>&amp; Gst::Element::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGst_1_1Element.html">Element</a>&amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a45110cdd5580e6fc7415a90ab19df50d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45110cdd5580e6fc7415a90ab19df50d">&#9670;&#160;</a></span>post_message() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gst::Element::post_message </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__gstreamermmEnums.html#ga704e8de3c3f9698d3c3ca15d61190a86">MessageType</a>&#160;</td>
          <td class="paramname"><em>type</em> = <code><a class="el" href="namespaceGst.html#ga704e8de3c3f9698d3c3ca15d61190a86a966198aa626095b0a0237e8e726be298">Gst::MESSAGE_INFO</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Glib::QueryQuark &amp;&#160;</td>
          <td class="paramname"><em>domain</em> = <code><a class="el" href="namespaceGst.html#aa186f9e9df937f6c544fce95bf25739b">get_core_error_quark</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Glib::ustring &amp;&#160;</td>
          <td class="paramname"><em>text</em> = <code>Glib::ustring()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Glib::ustring &amp;&#160;</td>
          <td class="paramname"><em>debug</em> = <code>Glib::ustring()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Glib::ustring &amp;&#160;</td>
          <td class="paramname"><em>file</em> = <code>Glib::ustring()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Glib::ustring &amp;&#160;</td>
          <td class="paramname"><em>function</em> = <code>Glib::ustring()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Post an error, warning or info message on the bus from inside an element. </p>
<p>type must be of <a class="el" href="namespaceGst.html#ga704e8de3c3f9698d3c3ca15d61190a86a758493cee50de74b68fa2fe29ba4bad9" title="An error occurred. ">Gst::MESSAGE_ERROR</a>, <a class="el" href="namespaceGst.html#ga704e8de3c3f9698d3c3ca15d61190a86a10897339e9a539206a3063366a001fe7" title="A warning occurred. ">Gst::MESSAGE_WARNING</a> or <a class="el" href="namespaceGst.html#ga704e8de3c3f9698d3c3ca15d61190a86a966198aa626095b0a0237e8e726be298" title="An info message occurred. ">Gst::MESSAGE_INFO</a>.</p>
<p>MT safe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code</td><td>The GError code belonging to the domain. </td></tr>
    <tr><td class="paramname">line</td><td>The source code line where the error was generated. </td></tr>
    <tr><td class="paramname">type</td><td>The GstMessageType. </td></tr>
    <tr><td class="paramname">domain</td><td>The GStreamer GError domain this message belongs to. </td></tr>
    <tr><td class="paramname">text</td><td>A text string to be used as a replacement for the default message connected to code. </td></tr>
    <tr><td class="paramname">debug</td><td>A debug message to be used as a replacement for the default debugging information. </td></tr>
    <tr><td class="paramname">file</td><td>The source code file where the error was generated. </td></tr>
    <tr><td class="paramname">function</td><td>The source code function where the error was generated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a26bbcf496949abc2b8f9f59cf0965f30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26bbcf496949abc2b8f9f59cf0965f30">&#9670;&#160;</a></span>post_message() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gst::Element::post_message </td>
          <td>(</td>
          <td class="paramtype">Glib::RefPtr&lt; <a class="el" href="classGst_1_1Message.html">Gst::Message</a> &gt;&amp;&amp;&#160;</td>
          <td class="paramname"><em>message</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Post a message on the element's <a class="el" href="classGst_1_1Bus.html" title="A class that encompasses the GStreamer asynchronous message bus subsystem. ">Gst::Bus</a>. </p>
<p>This function takes ownership of the message; if you want to access the message after this call, you should add an additional reference before calling.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td>A <a class="el" href="classGst_1_1Message.html" title="A class that represents lightweight objects to signal the application of pipeline events...">Gst::Message</a> to post. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the message was successfully posted. The function returns <code>false</code> if the element did not have a bus.</dd></dl>
<p>MT safe. </p>

</div>
</div>
<a id="ac04bed52183cca8e02e6d6dfb99318b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac04bed52183cca8e02e6d6dfb99318b5">&#9670;&#160;</a></span>post_message_vfunc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Gst::Element::post_message_vfunc </td>
          <td>(</td>
          <td class="paramtype">const Glib::RefPtr&lt; <a class="el" href="classGst_1_1Message.html">Gst::Message</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>message</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when a message is posted on the element. </p>
<p>Chain up to the parent class' handler to have it posted on the bus. </p>

</div>
</div>
<a id="aa2c85c09f45a4af156b3da9b0aeb0492"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2c85c09f45a4af156b3da9b0aeb0492">&#9670;&#160;</a></span>property()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Glib::RefPtr&lt;<a class="el" href="classGst_1_1Element.html">Gst::Element</a>&gt; Gst::Element::property </td>
          <td>(</td>
          <td class="paramtype">const Glib::ustring &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets specified property. </p>
<p>Allows to create property-chain (e.g. element-&gt;property("location", "test.ogg")-&gt;property("num_buffers", 20);</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The property name. </td></tr>
    <tr><td class="paramname">value</td><td>The property value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A this element. </dd></dl>

</div>
</div>
<a id="af7d7f25e4d79771efe256ff6c40ecbb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7d7f25e4d79771efe256ff6c40ecbb5">&#9670;&#160;</a></span>provide_clock() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::RefPtr&lt;<a class="el" href="classGst_1_1Clock.html">Gst::Clock</a>&gt; Gst::Element::provide_clock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the clock provided by the given element. </p>
<p>&lt;note&gt;An element is only required to provide a clock in the PAUSED state. Some elements can provide a clock in other states.&lt;/note&gt;</p>
<dl class="section return"><dt>Returns</dt><dd>The GstClock provided by the element or <code>nullptr</code> if no clock could be provided. Unref after usage.</dd></dl>
<p>MT safe. </p>

</div>
</div>
<a id="ac805b52da039e1b6e21463ec08da6031"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac805b52da039e1b6e21463ec08da6031">&#9670;&#160;</a></span>provide_clock() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::RefPtr&lt;const <a class="el" href="classGst_1_1Clock.html">Gst::Clock</a>&gt; Gst::Element::provide_clock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the clock provided by the given element. </p>
<p>&lt;note&gt;An element is only required to provide a clock in the PAUSED state. Some elements can provide a clock in other states.&lt;/note&gt;</p>
<dl class="section return"><dt>Returns</dt><dd>The GstClock provided by the element or <code>nullptr</code> if no clock could be provided. Unref after usage.</dd></dl>
<p>MT safe. </p>

</div>
</div>
<a id="acbd6faca7b79fd358af5a6a0b91a8600"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbd6faca7b79fd358af5a6a0b91a8600">&#9670;&#160;</a></span>provide_clock_vfunc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Glib::RefPtr&lt;<a class="el" href="classGst_1_1Clock.html">Gst::Clock</a>&gt; Gst::Element::provide_clock_vfunc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the <a class="el" href="classGst_1_1Clock.html" title="Abstract class for global clocks GStreamer uses a global clock to synchronize the plugins in a pipeli...">Gst::Clock</a> provided by the element. </p>

</div>
</div>
<a id="a471ae2f5290f5035f1b7b4de091394d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a471ae2f5290f5035f1b7b4de091394d3">&#9670;&#160;</a></span>query()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gst::Element::query </td>
          <td>(</td>
          <td class="paramtype">const Glib::RefPtr&lt; <a class="el" href="classGst_1_1Query.html">Gst::Query</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>query</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a query on the given element. </p>
<p>For elements that don't implement a query handler, this function forwards the query to a random srcpad or to the peer of a random linked sinkpad of this element.</p>
<p>Please note that some queries might need a running pipeline to work.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">query</td><td>The <a class="el" href="classGst_1_1Query.html" title="A class used to perform queries on pads and elements. ">Gst::Query</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the query could be performed.</dd></dl>
<p>MT safe. </p>

</div>
</div>
<a id="a820d8c912ac5fd4473b8129024285c8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a820d8c912ac5fd4473b8129024285c8c">&#9670;&#160;</a></span>query_convert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gst::Element::query_convert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__gstreamermmEnums.html#ga9aeb4c7c49680888ff819ac95fb13cff">Gst::Format</a>&#160;</td>
          <td class="paramname"><em>src_format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gint64&#160;</td>
          <td class="paramname"><em>src_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__gstreamermmEnums.html#ga9aeb4c7c49680888ff819ac95fb13cff">Format</a>&#160;</td>
          <td class="paramname"><em>dest_format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gint64 &amp;&#160;</td>
          <td class="paramname"><em>dest_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Queries an element to convert <em>src_val</em> in <em>src_format</em> to <em>dest_format</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src_format</td><td>A <a class="el" href="group__gstreamermmEnums.html#ga9aeb4c7c49680888ff819ac95fb13cff" title="Standard predefined formats. ">Gst::Format</a> to convert from. </td></tr>
    <tr><td class="paramname">src_val</td><td>A value to convert. </td></tr>
    <tr><td class="paramname">dest_format</td><td>The <a class="el" href="group__gstreamermmEnums.html#ga9aeb4c7c49680888ff819ac95fb13cff" title="Standard predefined formats. ">Gst::Format</a> to convert to. </td></tr>
    <tr><td class="paramname">dest_val</td><td>A pointer to the result. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the query could be performed. </dd></dl>

</div>
</div>
<a id="ae34be7370445472f300450045f5bbddd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae34be7370445472f300450045f5bbddd">&#9670;&#160;</a></span>query_duration() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gst::Element::query_duration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__gstreamermmEnums.html#ga9aeb4c7c49680888ff819ac95fb13cff">Gst::Format</a>&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gint64 &amp;&#160;</td>
          <td class="paramname"><em>duration</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Queries an element (usually top-level pipeline or playbin element) for the total stream duration in nanoseconds. </p>
<p>This query will only work once the pipeline is prerolled (i.e. reached PAUSED or PLAYING state). The application will receive an ASYNC_DONE message on the pipeline bus when that is the case.</p>
<p>If the duration changes for some reason, you will get a DURATION_CHANGED message on the pipeline bus, in which case you should re-query the duration using this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>The <a class="el" href="group__gstreamermmEnums.html#ga9aeb4c7c49680888ff819ac95fb13cff" title="Standard predefined formats. ">Gst::Format</a> requested. </td></tr>
    <tr><td class="paramname">duration</td><td>A location in which to store the total duration, or <code>nullptr</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the query could be performed. </dd></dl>

</div>
</div>
<a id="a77c57f566c07abba61c3bfb5f67f3fe9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77c57f566c07abba61c3bfb5f67f3fe9">&#9670;&#160;</a></span>query_duration() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gst::Element::query_duration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__gstreamermmEnums.html#ga9aeb4c7c49680888ff819ac95fb13cff">Gst::Format</a>&#160;</td>
          <td class="paramname"><em>format</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A <a class="el" href="classGst_1_1Element.html#ae34be7370445472f300450045f5bbddd" title="Queries an element (usually top-level pipeline or playbin element) for the total stream duration in n...">query_duration()</a> convenience overload. </p>

</div>
</div>
<a id="ab0224cc146c7e4fc0b57271f84803815"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0224cc146c7e4fc0b57271f84803815">&#9670;&#160;</a></span>query_position() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gst::Element::query_position </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__gstreamermmEnums.html#ga9aeb4c7c49680888ff819ac95fb13cff">Gst::Format</a>&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gint64 &amp;&#160;</td>
          <td class="paramname"><em>cur</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Queries an element (usually top-level pipeline or playbin element) for the stream position in nanoseconds. </p>
<p>This will be a value between 0 and the stream duration (if the stream duration is known). This query will usually only work once the pipeline is prerolled (i.e. reached PAUSED or PLAYING state). The application will receive an ASYNC_DONE message on the pipeline bus when that is the case.</p>
<p>If one repeatedly calls this function one can also create a query and reuse it in <a class="el" href="classGst_1_1Element.html#a471ae2f5290f5035f1b7b4de091394d3" title="Performs a query on the given element. ">query()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>The <a class="el" href="group__gstreamermmEnums.html#ga9aeb4c7c49680888ff819ac95fb13cff" title="Standard predefined formats. ">Gst::Format</a> requested. </td></tr>
    <tr><td class="paramname">cur</td><td>A location in which to store the current position, or <code>nullptr</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the query could be performed. </dd></dl>

</div>
</div>
<a id="a9466ba6bbd8bb80d48383d78fe1ee835"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9466ba6bbd8bb80d48383d78fe1ee835">&#9670;&#160;</a></span>query_position() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gst::Element::query_position </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__gstreamermmEnums.html#ga9aeb4c7c49680888ff819ac95fb13cff">Gst::Format</a>&#160;</td>
          <td class="paramname"><em>format</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A <a class="el" href="classGst_1_1Element.html#ab0224cc146c7e4fc0b57271f84803815" title="Queries an element (usually top-level pipeline or playbin element) for the stream position in nanosec...">query_position()</a> convenience overload. </p>

</div>
</div>
<a id="ac79bb6d05740a2a3c1a0e79cad55e527"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac79bb6d05740a2a3c1a0e79cad55e527">&#9670;&#160;</a></span>query_vfunc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Gst::Element::query_vfunc </td>
          <td>(</td>
          <td class="paramtype">const Glib::RefPtr&lt; <a class="el" href="classGst_1_1Query.html">Gst::Query</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>query</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a <a class="el" href="classGst_1_1Query.html" title="A class used to perform queries on pads and elements. ">Gst::Query</a> on the element. </p>

</div>
</div>
<a id="a17cc02bebfd099a1330a59467cef3f3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17cc02bebfd099a1330a59467cef3f3b">&#9670;&#160;</a></span>release_pad_vfunc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Gst::Element::release_pad_vfunc </td>
          <td>(</td>
          <td class="paramtype">const Glib::RefPtr&lt; <a class="el" href="classGst_1_1Pad.html">Gst::Pad</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>pad</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when a request pad is to be released. </p>

</div>
</div>
<a id="aa614a038b969d37f5db69999e6200c7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa614a038b969d37f5db69999e6200c7a">&#9670;&#160;</a></span>release_request_pad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gst::Element::release_request_pad </td>
          <td>(</td>
          <td class="paramtype">const Glib::RefPtr&lt; <a class="el" href="classGst_1_1Pad.html">Gst::Pad</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>pad</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes the element free the previously requested pad as obtained with <a class="el" href="classGst_1_1Element.html#aea8e7821ecf7acdd24bb08b0e638caa7" title="Retrieves a pad from the element by name (e.g. &quot;src_\\%d&quot;). ">get_request_pad()</a>. </p>
<p>MT safe. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pad</td><td>The <a class="el" href="classGst_1_1Pad.html" title="A class that represents objects contained by elements that allows links to other elements. ">Gst::Pad</a> to release. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a61b542aafbb389d69da3033725521d6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61b542aafbb389d69da3033725521d6d">&#9670;&#160;</a></span>remove_pad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gst::Element::remove_pad </td>
          <td>(</td>
          <td class="paramtype">const Glib::RefPtr&lt; <a class="el" href="classGst_1_1Pad.html">Gst::Pad</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>pad</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes <em>pad</em> from <em>element</em>. </p>
<p><em>pad</em> will be destroyed if it has not been referenced elsewhere using <a class="el" href="classGst_1_1Object.html#a45b87529c337e40f03e34bca450e41bc" title="Clear the parent of object, removing the associated reference. ">Gst::Object::unparent()</a>.</p>
<p>This function is used by plugin developers and should not be used by applications. Pads that were dynamically requested from elements with <a class="el" href="classGst_1_1Element.html#ad082533664f013db0c3e629a00142464" title="Retrieves a request pad from the element according to the provided template. ">request_pad()</a> should be released with the <a class="el" href="classGst_1_1Element.html#aa614a038b969d37f5db69999e6200c7a" title="Makes the element free the previously requested pad as obtained with get_request_pad(). ">release_request_pad()</a> function instead.</p>
<p>Pads are not automatically deactivated so elements should perform the needed steps to deactivate the pad in case this pad is removed in the PAUSED or PLAYING state. See <a class="el" href="classGst_1_1Pad.html#ae4310bd528bc3eb83c237885133b811a" title="Activates or deactivates the given pad. ">Gst::Pad::set_active()</a> for more information about deactivating pads.</p>
<p>The pad and the element should be unlocked when calling this function.</p>
<p>This function will emit the <a class="el" href="classGst_1_1Element.html#a00f82141e3f402192b056fcb42aa24d4">Gst::Element::signal_pad_removed()</a> signal on the element.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pad</td><td>The <a class="el" href="classGst_1_1Pad.html" title="A class that represents objects contained by elements that allows links to other elements. ">Gst::Pad</a> to remove from the element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the pad could be removed. Can return <code>false</code> if the pad does not belong to the provided element.</dd></dl>
<p>MT safe. </p>

</div>
</div>
<a id="ab459dfdb70ef2a61202e8ff467595763"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab459dfdb70ef2a61202e8ff467595763">&#9670;&#160;</a></span>request_new_pad_vfunc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Glib::RefPtr&lt;<a class="el" href="classGst_1_1Pad.html">Gst::Pad</a>&gt; Gst::Element::request_new_pad_vfunc </td>
          <td>(</td>
          <td class="paramtype">Glib::RefPtr&lt; <a class="el" href="classGst_1_1PadTemplate.html">Gst::PadTemplate</a> &gt;&#160;</td>
          <td class="paramname"><em>templ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Glib::ustring &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Glib::RefPtr&lt; const <a class="el" href="classGst_1_1Caps.html">Gst::Caps</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>caps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when a new pad is requested. </p>

</div>
</div>
<a id="ad082533664f013db0c3e629a00142464"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad082533664f013db0c3e629a00142464">&#9670;&#160;</a></span>request_pad() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::RefPtr&lt;<a class="el" href="classGst_1_1Pad.html">Gst::Pad</a>&gt; Gst::Element::request_pad </td>
          <td>(</td>
          <td class="paramtype">const Glib::RefPtr&lt; <a class="el" href="classGst_1_1PadTemplate.html">Gst::PadTemplate</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>templ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Glib::ustring &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Glib::RefPtr&lt; const <a class="el" href="classGst_1_1Caps.html">Gst::Caps</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>caps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves a request pad from the element according to the provided template. </p>
<p><a class="el" href="classGst_1_1Pad.html" title="A class that represents objects contained by elements that allows links to other elements. ">Pad</a> templates can be looked up using <a class="el" href="classGst_1_1ElementFactory.html#a82a88bfd944f753f3832544ce2bbe303" title="Gets the List of Gst::StaticPadTemplate for this factory. ">Gst::ElementFactory::get_static_pad_templates()</a>.</p>
<p>The pad should be released with <a class="el" href="classGst_1_1Element.html#aa614a038b969d37f5db69999e6200c7a" title="Makes the element free the previously requested pad as obtained with get_request_pad(). ">release_request_pad()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">templ</td><td>A <a class="el" href="classGst_1_1PadTemplate.html" title="A class that describes the media type of a pad. ">Gst::PadTemplate</a> of which we want a pad of. </td></tr>
    <tr><td class="paramname">name</td><td>The name of the request <a class="el" href="classGst_1_1Pad.html" title="A class that represents objects contained by elements that allows links to other elements. ">Gst::Pad</a> to retrieve. Can be <code>nullptr</code>. </td></tr>
    <tr><td class="paramname">caps</td><td>The caps of the pad we want to request. Can be <code>nullptr</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Requested <a class="el" href="classGst_1_1Pad.html" title="A class that represents objects contained by elements that allows links to other elements. ">Gst::Pad</a> if found, otherwise <code>nullptr</code>. Release after usage. </dd></dl>

</div>
</div>
<a id="a90acea759133eb20d42bc5ace1c2eff3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90acea759133eb20d42bc5ace1c2eff3">&#9670;&#160;</a></span>request_pad() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::RefPtr&lt;<a class="el" href="classGst_1_1Pad.html">Gst::Pad</a>&gt; Gst::Element::request_pad </td>
          <td>(</td>
          <td class="paramtype">const Glib::RefPtr&lt; <a class="el" href="classGst_1_1PadTemplate.html">Gst::PadTemplate</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>templ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Glib::ustring &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A <a class="el" href="classGst_1_1Element.html#ad082533664f013db0c3e629a00142464" title="Retrieves a request pad from the element according to the provided template. ">request_pad()</a> convenience overload. </p>

</div>
</div>
<a id="ae726bdf0cfd604bb612ab8aca76e8833"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae726bdf0cfd604bb612ab8aca76e8833">&#9670;&#160;</a></span>request_pad() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::RefPtr&lt;<a class="el" href="classGst_1_1Pad.html">Gst::Pad</a>&gt; Gst::Element::request_pad </td>
          <td>(</td>
          <td class="paramtype">const Glib::RefPtr&lt; <a class="el" href="classGst_1_1PadTemplate.html">Gst::PadTemplate</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>templ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Glib::RefPtr&lt; const <a class="el" href="classGst_1_1Caps.html">Gst::Caps</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>caps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A <a class="el" href="classGst_1_1Element.html#ad082533664f013db0c3e629a00142464" title="Retrieves a request pad from the element according to the provided template. ">request_pad()</a> convenience overload. </p>

</div>
</div>
<a id="ae53c76cd339a8d3b5a8bc676a577b578"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae53c76cd339a8d3b5a8bc676a577b578">&#9670;&#160;</a></span>request_pad() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::RefPtr&lt;<a class="el" href="classGst_1_1Pad.html">Gst::Pad</a>&gt; Gst::Element::request_pad </td>
          <td>(</td>
          <td class="paramtype">const Glib::RefPtr&lt; <a class="el" href="classGst_1_1PadTemplate.html">Gst::PadTemplate</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>templ</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A <a class="el" href="classGst_1_1Element.html#ad082533664f013db0c3e629a00142464" title="Retrieves a request pad from the element according to the provided template. ">request_pad()</a> convenience overload. </p>

</div>
</div>
<a id="a3341e4076fd02159a6fe9a2a042f42ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3341e4076fd02159a6fe9a2a042f42ae">&#9670;&#160;</a></span>seek() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gst::Element::seek </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__gstreamermmEnums.html#ga9aeb4c7c49680888ff819ac95fb13cff">Format</a>&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__gstreamermmEnums.html#ga511d96d2c1136202d0d4b90de2485cf3">SeekFlags</a>&#160;</td>
          <td class="paramname"><em>seek_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gint64&#160;</td>
          <td class="paramname"><em>seek_pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simple API to perform a seek on the given element, meaning it just seeks to the given position relative to the start of the stream. </p>
<p>For more complex operations like segment seeks (e.g. for looping) or changing the playback rate or seeking relative to the last configured playback segment you should use <a class="el" href="classGst_1_1Element.html#a3341e4076fd02159a6fe9a2a042f42ae" title="Simple API to perform a seek on the given element, meaning it just seeks to the given position relati...">seek()</a>.</p>
<p>In a completely prerolled PAUSED or PLAYING pipeline, seeking is always guaranteed to return <code>true</code> on a seekable media type or <code>false</code> when the media type is certainly not seekable (such as a live stream).</p>
<p>Some elements allow for seeking in the READY state, in this case they will store the seek event and execute it when they are put to PAUSED. If the element supports seek in READY, it will always return <code>true</code> when it receives the event in the READY state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>A <a class="el" href="group__gstreamermmEnums.html#ga9aeb4c7c49680888ff819ac95fb13cff" title="Standard predefined formats. ">Gst::Format</a> to execute the seek in, such as <a class="el" href="namespaceGst.html#ga9aeb4c7c49680888ff819ac95fb13cffa3ce5ad3e79ef738bd4e7a6308db1c70d" title="Time in nanoseconds. ">Gst::FORMAT_TIME</a>. </td></tr>
    <tr><td class="paramname">seek_flags</td><td>Seek options; playback applications will usually want to use GST_SEEK_FLAG_FLUSH | GST_SEEK_FLAG_KEY_UNIT here. </td></tr>
    <tr><td class="paramname">seek_pos</td><td>Position to seek to (relative to the start); if you are doing a seek in <a class="el" href="namespaceGst.html#ga9aeb4c7c49680888ff819ac95fb13cffa3ce5ad3e79ef738bd4e7a6308db1c70d" title="Time in nanoseconds. ">Gst::FORMAT_TIME</a> this value is in nanoseconds - multiply with <a class="el" href="namespaceGst.html#a4bde1acd8d4b2473abaa40db00c72606" title="A constant that defines one GStreamer second. ">Gst::SECOND</a> to convert seconds to nanoseconds or with Gst::MSECOND to convert milliseconds to nanoseconds. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the seek operation succeeded. Flushing seeks will trigger a preroll, which will emit <a class="el" href="namespaceGst.html#ga704e8de3c3f9698d3c3ca15d61190a86a724a5ea02125c3c562688fea62c565f1" title="Posted by elements when they complete an ASYNC Gst::StateChange. ">Gst::MESSAGE_ASYNC_DONE</a>. </dd></dl>

</div>
</div>
<a id="a430a01725519d8b2f6e8dd508284028f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a430a01725519d8b2f6e8dd508284028f">&#9670;&#160;</a></span>seek() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gst::Element::seek </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__gstreamermmEnums.html#ga9aeb4c7c49680888ff819ac95fb13cff">Format</a>&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__gstreamermmEnums.html#ga511d96d2c1136202d0d4b90de2485cf3">SeekFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__gstreamermmEnums.html#gaa7c6407bbc8040f51718d1be753422c0">SeekType</a>&#160;</td>
          <td class="paramname"><em>cur_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gint64&#160;</td>
          <td class="paramname"><em>cur</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__gstreamermmEnums.html#gaa7c6407bbc8040f51718d1be753422c0">SeekType</a>&#160;</td>
          <td class="paramname"><em>stop_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gint64&#160;</td>
          <td class="paramname"><em>stop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends a seek event to an element. </p>
<p>See Gst::Event::new_seek() for the details of the parameters. The seek event is sent to the element using <a class="el" href="classGst_1_1Element.html#a01caf7800f24670bd3c152fb2b8f3a2a" title="Sends an event to an element. ">send_event()</a>.</p>
<p>MT safe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rate</td><td>The new playback rate. </td></tr>
    <tr><td class="paramname">format</td><td>The format of the seek values. </td></tr>
    <tr><td class="paramname">flags</td><td>The optional seek flags. </td></tr>
    <tr><td class="paramname">cur_type</td><td>The type and flags for the new start position. </td></tr>
    <tr><td class="paramname">cur</td><td>The value of the new start position. </td></tr>
    <tr><td class="paramname">stop_type</td><td>The type and flags for the new stop position. </td></tr>
    <tr><td class="paramname">stop</td><td>The value of the new stop position. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the event was handled. Flushing seeks will trigger a preroll, which will emit <a class="el" href="namespaceGst.html#ga704e8de3c3f9698d3c3ca15d61190a86a724a5ea02125c3c562688fea62c565f1" title="Posted by elements when they complete an ASYNC Gst::StateChange. ">Gst::MESSAGE_ASYNC_DONE</a>. </dd></dl>

</div>
</div>
<a id="a01caf7800f24670bd3c152fb2b8f3a2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01caf7800f24670bd3c152fb2b8f3a2a">&#9670;&#160;</a></span>send_event() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gst::Element::send_event </td>
          <td>(</td>
          <td class="paramtype">Glib::RefPtr&lt; <a class="el" href="classGst_1_1Event.html">Gst::Event</a> &gt;&amp;&amp;&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends an event to an element. </p>
<p>If the element doesn't implement an event handler, the event will be pushed on a random linked sink pad for downstream events or a random linked source pad for upstream events.</p>
<p>This function takes ownership of the provided event so you should Gst::Event::ref() it if you want to reuse the event after this call.</p>
<p>MT safe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>The <a class="el" href="classGst_1_1Event.html" title="A class that represents events that are passed up and down a pipeline. ">Gst::Event</a> to send to the element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the event was handled. Events that trigger a preroll (such as flushing seeks and steps) will emit <a class="el" href="namespaceGst.html#ga704e8de3c3f9698d3c3ca15d61190a86a724a5ea02125c3c562688fea62c565f1" title="Posted by elements when they complete an ASYNC Gst::StateChange. ">Gst::MESSAGE_ASYNC_DONE</a>. </dd></dl>

</div>
</div>
<a id="a2dee29e72f60948351e91ef45c1cd3fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dee29e72f60948351e91ef45c1cd3fb">&#9670;&#160;</a></span>send_event() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gst::Element::send_event </td>
          <td>(</td>
          <td class="paramtype">const Glib::RefPtr&lt; <a class="el" href="classGst_1_1Event.html">Gst::Event</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A <a class="el" href="classGst_1_1Element.html#a01caf7800f24670bd3c152fb2b8f3a2a" title="Sends an event to an element. ">send_event()</a> convenience overload. Allows to re-use <em>event</em> parameter after function call. </p>

</div>
</div>
<a id="a2c6eb96eca5dbffe165cc7f8f00f0de6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c6eb96eca5dbffe165cc7f8f00f0de6">&#9670;&#160;</a></span>send_event_vfunc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Gst::Element::send_event_vfunc </td>
          <td>(</td>
          <td class="paramtype">const Glib::RefPtr&lt; <a class="el" href="classGst_1_1Event.html">Gst::Event</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send a <a class="el" href="classGst_1_1Event.html" title="A class that represents events that are passed up and down a pipeline. ">Gst::Event</a> to the element. </p>

</div>
</div>
<a id="a0428a1c8126fc13c27c0df8e713b6aa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0428a1c8126fc13c27c0df8e713b6aa7">&#9670;&#160;</a></span>set_base_time()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gst::Element::set_base_time </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">ClockTime</a>&#160;</td>
          <td class="paramname"><em>time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the base time of an element. </p>
<p>See <a class="el" href="classGst_1_1Element.html#abe5138d41072cfc8c3af1805d44b1e54" title="Returns the base time of the element. ">get_base_time()</a>.</p>
<p>MT safe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time</td><td>The base time to set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3db6b352dc7023246a1dd6592810cccb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3db6b352dc7023246a1dd6592810cccb">&#9670;&#160;</a></span>set_bus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gst::Element::set_bus </td>
          <td>(</td>
          <td class="paramtype">const Glib::RefPtr&lt; <a class="el" href="classGst_1_1Bus.html">Gst::Bus</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>bus</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the bus of the element. </p>
<p>Increases the refcount on the bus. For internal use only, unless you're testing elements.</p>
<p>MT safe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bus</td><td>The <a class="el" href="classGst_1_1Bus.html" title="A class that encompasses the GStreamer asynchronous message bus subsystem. ">Gst::Bus</a> to set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a404fa6688b0f042f1dc46d2e22fc7dbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a404fa6688b0f042f1dc46d2e22fc7dbc">&#9670;&#160;</a></span>set_bus_vfunc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Gst::Element::set_bus_vfunc </td>
          <td>(</td>
          <td class="paramtype">const Glib::RefPtr&lt; <a class="el" href="classGst_1_1Bus.html">Gst::Bus</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>bus</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a <a class="el" href="classGst_1_1Bus.html" title="A class that encompasses the GStreamer asynchronous message bus subsystem. ">Gst::Bus</a> on the element. </p>

</div>
</div>
<a id="ad1a766827de41c955da267718c76db9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1a766827de41c955da267718c76db9a">&#9670;&#160;</a></span>set_clock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gst::Element::set_clock </td>
          <td>(</td>
          <td class="paramtype">const Glib::RefPtr&lt; <a class="el" href="classGst_1_1Clock.html">Gst::Clock</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>clock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the clock for the element. </p>
<p>This function increases the refcount on the clock. Any previously set clock on the object is unreffed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clock</td><td>The <a class="el" href="classGst_1_1Clock.html" title="Abstract class for global clocks GStreamer uses a global clock to synchronize the plugins in a pipeli...">Gst::Clock</a> to set for the element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the element accepted the clock. An element can refuse a clock when it, for example, is not able to slave its internal clock to the <em>clock</em> or when it requires a specific clock to operate.</dd></dl>
<p>MT safe. </p>

</div>
</div>
<a id="a4e0baa09a835bdcef521b5f6aa0a387f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e0baa09a835bdcef521b5f6aa0a387f">&#9670;&#160;</a></span>set_clock_vfunc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Gst::Element::set_clock_vfunc </td>
          <td>(</td>
          <td class="paramtype">const Glib::RefPtr&lt; <a class="el" href="classGst_1_1Clock.html">Gst::Clock</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>clock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the <a class="el" href="classGst_1_1Clock.html" title="Abstract class for global clocks GStreamer uses a global clock to synchronize the plugins in a pipeli...">Gst::Clock</a> on the element. </p>

</div>
</div>
<a id="aacb864fcef4a93fc45a9af3627db0c6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacb864fcef4a93fc45a9af3627db0c6b">&#9670;&#160;</a></span>set_context()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gst::Element::set_context </td>
          <td>(</td>
          <td class="paramtype">const Glib::RefPtr&lt; <a class="el" href="classGst_1_1Context.html">Gst::Context</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the context of the element. </p>
<p>Increases the refcount of the context.</p>
<p>MT safe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The <a class="el" href="classGst_1_1Context.html" title="Lightweight objects to represent element contexts. ">Gst::Context</a> to set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0a910b5a5812341da6a9568f59dc9d51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a910b5a5812341da6a9568f59dc9d51">&#9670;&#160;</a></span>set_context_vfunc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Gst::Element::set_context_vfunc </td>
          <td>(</td>
          <td class="paramtype">const Glib::RefPtr&lt; <a class="el" href="classGst_1_1Context.html">Gst::Context</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a <a class="el" href="classGst_1_1Context.html" title="Lightweight objects to represent element contexts. ">Gst::Context</a> on the element. </p>

</div>
</div>
<a id="a806dffc144477f00ca9a2f34a5b0f8ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a806dffc144477f00ca9a2f34a5b0f8ca">&#9670;&#160;</a></span>set_locked_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gst::Element::set_locked_state </td>
          <td>(</td>
          <td class="paramtype">gboolean&#160;</td>
          <td class="paramname"><em>locked_state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Locks the state of an element, so state changes of the parent don't affect this element anymore. </p>
<p>MT safe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">locked_state</td><td><code>true</code> to lock the element's state. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the state was changed, <code>false</code> if bad parameters were given or the elements state-locking needed no change. </dd></dl>

</div>
</div>
<a id="ad01eb1b7406d6bc80de1c5184b8388d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad01eb1b7406d6bc80de1c5184b8388d2">&#9670;&#160;</a></span>set_start_time()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gst::Element::set_start_time </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceGst.html#ad35f82b74cae5822fe16b231e8293cda">Gst::ClockTime</a>&#160;</td>
          <td class="paramname"><em>time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the start time of an element. </p>
<p>The start time of the element is the running time of the element when it last went to the PAUSED state. In READY or after a flushing seek, it is set to 0.</p>
<p>Toplevel elements like <a class="el" href="classGst_1_1Pipeline.html" title="A top-level bin with clocking and bus management functionality. ">Gst::Pipeline</a> will manage the start_time and base_time on its children. Setting the start_time to <a class="el" href="namespaceGst.html#a07ca62fa6d891070ab6d46c45cd388f1" title="A constant to define an undefined clock time. ">Gst::CLOCK_TIME_NONE</a> on such a toplevel element will disable the distribution of the base_time to the children and can be useful if the application manages the base_time itself, for example if you want to synchronize capture from multiple pipelines, and you can also ensure that the pipelines have the same clock.</p>
<p>MT safe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time</td><td>The base time to set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9f99dbf420c0f34005662dac54fb16b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f99dbf420c0f34005662dac54fb16b7">&#9670;&#160;</a></span>set_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__gstreamermmEnums.html#gacaa5e30b631a84cf95a0f8918e96f025">StateChangeReturn</a> Gst::Element::set_state </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__gstreamermmEnums.html#gabb043e1d41659fd842f10949f91e7a7f">State</a>&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the state of the element. </p>
<p>This function will try to set the requested state by going through all the intermediary states and calling the class's state change function for each.</p>
<p>This function can return <a class="el" href="namespaceGst.html#gacaa5e30b631a84cf95a0f8918e96f025a77e50c46cf3919c152686b71cd419c3a" title="The state change will happen asynchronously. ">Gst::STATE_CHANGE_ASYNC</a>, in which case the element will perform the remainder of the state change asynchronously in another thread. An application can use <a class="el" href="classGst_1_1Element.html#a74b7e2811f2d7d4a5ae49e43eace975e" title="Gets the state of the element. ">get_state()</a> to wait for the completion of the state change or it can wait for a <a class="el" href="namespaceGst.html#ga704e8de3c3f9698d3c3ca15d61190a86a724a5ea02125c3c562688fea62c565f1" title="Posted by elements when they complete an ASYNC Gst::StateChange. ">Gst::MESSAGE_ASYNC_DONE</a> or <a class="el" href="namespaceGst.html#ga704e8de3c3f9698d3c3ca15d61190a86a5e5e2670b33ceaf72a35dadbdb72bfe4" title="A state change happened. ">Gst::MESSAGE_STATE_CHANGED</a> on the bus.</p>
<p>State changes to <a class="el" href="namespaceGst.html#gabb043e1d41659fd842f10949f91e7a7fae477937b92150d7f989ca9d1fa3a0da0" title="The element is ready to go to PAUSED. ">Gst::STATE_READY</a> or <a class="el" href="namespaceGst.html#gabb043e1d41659fd842f10949f91e7a7fa07cf1506b030700024ecf1654c3796c2" title="The nullptr state or initial state of an element. ">Gst::STATE_NULL</a> never return <a class="el" href="namespaceGst.html#gacaa5e30b631a84cf95a0f8918e96f025a77e50c46cf3919c152686b71cd419c3a" title="The state change will happen asynchronously. ">Gst::STATE_CHANGE_ASYNC</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The element's new <a class="el" href="group__gstreamermmEnums.html#gabb043e1d41659fd842f10949f91e7a7f" title="The possible states an element can be in. ">Gst::State</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result of the state change using <a class="el" href="group__gstreamermmEnums.html#gacaa5e30b631a84cf95a0f8918e96f025" title="The possible return values from a state change function such as Gst::Element::set_state(). ">Gst::StateChangeReturn</a>.</dd></dl>
<p>MT safe. </p>

</div>
</div>
<a id="ab78ac5519d084e4d06c913c276f2d11b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab78ac5519d084e4d06c913c276f2d11b">&#9670;&#160;</a></span>set_state_vfunc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__gstreamermmEnums.html#gacaa5e30b631a84cf95a0f8918e96f025">StateChangeReturn</a> Gst::Element::set_state_vfunc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__gstreamermmEnums.html#gabb043e1d41659fd842f10949f91e7a7f">State</a>&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a new state on the element. </p>

</div>
</div>
<a id="a419abecd2a358f6157ba82dbb2f1e067"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a419abecd2a358f6157ba82dbb2f1e067">&#9670;&#160;</a></span>signal_no_more_pads()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::SignalProxy&lt; void &gt; Gst::Element::signal_no_more_pads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section user"><dt>Slot Prototype:</dt><dd><code>void on_my_no_more_pads()</code></dd></dl>
<p>This signals that the element will not generate more dynamic pads. Note that this signal will usually be emitted from the context of the streaming thread. </p>

</div>
</div>
<a id="aaaf2d91e5aafe78141c3cf8c80724938"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaf2d91e5aafe78141c3cf8c80724938">&#9670;&#160;</a></span>signal_pad_added()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::SignalProxy&lt; void,const Glib::RefPtr&lt;<a class="el" href="classGst_1_1Pad.html">Gst::Pad</a>&gt;&amp; &gt; Gst::Element::signal_pad_added </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section user"><dt>Slot Prototype:</dt><dd><code>void on_my_pad_added(const Glib::RefPtr&lt;Gst::Pad&gt;&amp; new_pad)</code></dd></dl>
<p>a new <a class="el" href="classGst_1_1Pad.html" title="A class that represents objects contained by elements that allows links to other elements. ">Gst::Pad</a> has been added to the element. Note that this signal will usually be emitted from the context of the streaming thread. Also keep in mind that if you add new elements to the pipeline in the signal handler you will need to set them to the desired target state with <a class="el" href="classGst_1_1Element.html#a9f99dbf420c0f34005662dac54fb16b7" title="Sets the state of the element. ">Gst::Element::set_state()</a> or <a class="el" href="classGst_1_1Element.html#a6d198b8f460ccc16641d5a21b2975ec0" title="Tries to change the state of the element to the same as its parent. ">Gst::Element::sync_state_with_parent()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_pad</td><td>The pad that has been added. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a00f82141e3f402192b056fcb42aa24d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00f82141e3f402192b056fcb42aa24d4">&#9670;&#160;</a></span>signal_pad_removed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::SignalProxy&lt; void,const Glib::RefPtr&lt;<a class="el" href="classGst_1_1Pad.html">Gst::Pad</a>&gt;&amp; &gt; Gst::Element::signal_pad_removed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section user"><dt>Slot Prototype:</dt><dd><code>void on_my_pad_removed(const Glib::RefPtr&lt;Gst::Pad&gt;&amp; old_pad)</code></dd></dl>
<p>a <a class="el" href="classGst_1_1Pad.html" title="A class that represents objects contained by elements that allows links to other elements. ">Gst::Pad</a> has been removed from the element</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">old_pad</td><td>The pad that has been removed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad784f418931639b085b3cf567c175e5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad784f418931639b085b3cf567c175e5c">&#9670;&#160;</a></span>state_changed_vfunc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Gst::Element::state_changed_vfunc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__gstreamermmEnums.html#gabb043e1d41659fd842f10949f91e7a7f">Gst::State</a>&#160;</td>
          <td class="paramname"><em>oldstate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__gstreamermmEnums.html#gabb043e1d41659fd842f10949f91e7a7f">Gst::State</a>&#160;</td>
          <td class="paramname"><em>newstate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__gstreamermmEnums.html#gabb043e1d41659fd842f10949f91e7a7f">Gst::State</a>&#160;</td>
          <td class="paramname"><em>pending</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called immediately after a new state was set. </p>

</div>
</div>
<a id="a6d198b8f460ccc16641d5a21b2975ec0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d198b8f460ccc16641d5a21b2975ec0">&#9670;&#160;</a></span>sync_state_with_parent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gst::Element::sync_state_with_parent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tries to change the state of the element to the same as its parent. </p>
<p>If this function returns <code>false</code>, the state of element is undefined.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code>, if the element's state could be synced to the parent's state.</dd></dl>
<p>MT safe. </p>

</div>
</div>
<a id="a82f5083595abf391729cfa6085090dbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82f5083595abf391729cfa6085090dbd">&#9670;&#160;</a></span>unlink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gst::Element::unlink </td>
          <td>(</td>
          <td class="paramtype">const Glib::RefPtr&lt; <a class="el" href="classGst_1_1Element.html">Gst::Element</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>dest</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unlinks all source pads of the source element with all sink pads of the sink element to which they are linked. </p>
<p>If the link has been made using <a class="el" href="classGst_1_1Element.html#ab41115df14a718d340380c2d719a6ae4" title="Links this source element to the dest element. ">link()</a>, it could have created an requestpad, which has to be released using <a class="el" href="classGst_1_1Element.html#aa614a038b969d37f5db69999e6200c7a" title="Makes the element free the previously requested pad as obtained with get_request_pad(). ">release_request_pad()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The sink <a class="el" href="classGst_1_1Element.html" title="Abstract base class for all pipeline elements. ">Gst::Element</a> to unlink. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae9a9c3d2b226dfb6920f2e8152ffb5b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9a9c3d2b226dfb6920f2e8152ffb5b3">&#9670;&#160;</a></span>unlink_pads()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gst::Element::unlink_pads </td>
          <td>(</td>
          <td class="paramtype">const Glib::ustring &amp;&#160;</td>
          <td class="paramname"><em>srcpadname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Glib::RefPtr&lt; <a class="el" href="classGst_1_1Element.html">Gst::Element</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Glib::ustring &amp;&#160;</td>
          <td class="paramname"><em>destpadname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unlinks the two named pads of the source and destination elements. </p>
<p>This is a convenience function for <a class="el" href="classGst_1_1Pad.html#ae17d28284b59e51fc6ad8acfd264d037" title="Unlinks the source pad from the sink pad. ">Gst::Pad::unlink()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">srcpadname</td><td>The name of the <a class="el" href="classGst_1_1Pad.html" title="A class that represents objects contained by elements that allows links to other elements. ">Gst::Pad</a> in source element. </td></tr>
    <tr><td class="paramname">dest</td><td>A <a class="el" href="classGst_1_1Element.html" title="Abstract base class for all pipeline elements. ">Gst::Element</a> containing the destination pad. </td></tr>
    <tr><td class="paramname">destpadname</td><td>The name of the <a class="el" href="classGst_1_1Pad.html" title="A class that represents objects contained by elements that allows links to other elements. ">Gst::Pad</a> in destination element. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a7128ca440b26df3c7807db690b03e572"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7128ca440b26df3c7807db690b03e572">&#9670;&#160;</a></span>wrap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Glib::RefPtr&lt; <a class="el" href="classGst_1_1Element.html">Gst::Element</a> &gt; wrap </td>
          <td>(</td>
          <td class="paramtype">GstElement *&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>take_copy</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A <a class="el" href="namespaceGlib.html#a43fcab2a44083e8b7b6a1c8193acae2b">Glib::wrap()</a> method for this object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">object</td><td>The C instance. </td></tr>
    <tr><td class="paramname">take_copy</td><td>False if the result should take ownership of the C instance. True if it should take a new copy or ref. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A C++ instance that wraps this C instance. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Oct 21 2017 12:59:00 for gstreamermm by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
